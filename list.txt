------- FILE dodge_it.asm LEVEL 1 PASS 2
      1  1000 ????						;-------------------------------------------------------------------------------
      2  1000 ????						; Dodge It - Videocart 16
      3  1000 ????						;  for the Fairchild Video Entertainment System
      4  1000 ????						; Original Code Copyright Â© 1978, Fairchild Semiconductor
      5  1000 ????						;
      6  1000 ????						; Disassembly Generated using Peter Trauner's f8tool
      7  1000 ????						;
      8  1000 ????						; Comments, Labels, Etc. added by
      9  1000 ????						;  Alex West
     10  1000 ????						;
     11  1000 ????						; Thanks to http://channelf.se/veswiki/ for making this possible
     12  1000 ????						;
     13  1000 ????						; A text file of the instruction manual can be found here:
     14  1000 ????						; http://channelf.se/gallery/txt/videocart16.txt
     15  1000 ????						;
     16  1000 ????						; Build Instructions
     17  1000 ????						;  dasm dodge_it.asm -f3 -ododge_it.bin
     18  1000 ????
     19  1000 ????						; Terms
     20  1000 ????						; - mid-function - A function called from the main thread that saves and restores
     21  1000 ????						;    the return address using LR K,P, LR P,K, or PK, that calls other functions.
     22  1000 ????						; - leaf-function - A function that is called from main or a mid function that
     23  1000 ????						;    does not save context and does not call other functions.
     24  1000 ????
     25  1000 ????				      processor	f8
     26  1000 ????
------- FILE ves.h LEVEL 2 PASS 2
      0  1000 ????				      include	"ves.h"
      1  1000 ????						; VES.H
      2  1000 ????						; Fairchild Channel F Header
      3  1000 ????						; Version x
      4  1000 ????
      5  1000 ????	       00 65	   VERSION_CHANNELF =	101
      6  1000 ????	       00 65	   VERSION_VES =	101
      7  1000 ????
      8  1000 ????						; Ignore these paragraphs below for the moment. - alex
      9  1000 ????
     10  1000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VES.H
     11  1000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     12  1000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     13  1000 ????						;
     14  1000 ????						; This file defines hardware registers and memory mapping for the
     15  1000 ????						; Fairchild Channel-F. It is distributed as a companion machine-specific support package
     16  1000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     17  1000 ????						; available at at http://www.atari2600.org/dasm
     18  1000 ????						;
     19  1000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     20  1000 ????						; contributed to understanding the Channel-F.	If you take issue with the
     21  1000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     22  1000 ????						; with your views.  Please contribute, if you think you can improve this
     23  1000 ????						; file!
     24  1000 ????						;
     25  1000 ????						; Latest Revisions...
     26  1000 ????						; 1.01   2/NOV/2004	Kevin Lipe's version (combined macro/header)
     27  1000 ????						;			renamed to VES.H
     28  1000 ????						;			alternates provided for deprecated equates
     29  1000 ????						;			ALL hardware/BIOS equates now in uppercase and prefixed
     30  1000 ????						; 1.00  31/OCT/2004	- initial release
     31  1000 ????
     32  1000 ????
     33  1000 ????						; Please contribute Channel-F header code to atari2600@taswegian.com
     34  1000 ????
     35  1000 ????
     36  1000 ????						;-------------------------------------------------------------------------------
     37  1000 ????						; BIOS Calls
     38  1000 ????						;------------------------
     39  1000 ????
     40  1000 ????	       00 d0	   BIOS_CLEAR_SCREEN =	$00d0	; uses r31
     41  1000 ????	       00 8f	   BIOS_DELAY =	$008f
     42  1000 ????	       01 07	   BIOS_PUSH_K =	$0107	; used to allow more subroutine stack space
     43  1000 ????	       01 1e	   BIOS_POP_K =	$011e
     44  1000 ????	       06 79	   BIOS_DRAW_CHARACTER =	$0679
     45  1000 ????
     46  1000 ????						;-------------------------------------------------------------------------------
     47  1000 ????						; Colors
     48  1000 ????
     49  1000 ????	       00 40	   COLOR_RED  =	$40
     50  1000 ????	       00 80	   COLOR_BLUE =	$80
     51  1000 ????	       00 00	   COLOR_GREEN =	$00
     52  1000 ????	       00 c0	   COLOR_BACKGROUND =	$C0
     53  1000 ????
     54  1000 ????						; TODO: Verify
     55  1000 ????	       00 00	   BG_COLOR_GREEN =	%00000000
     56  1000 ????	       00 30	   BG_COLOR_BLUE =	%00110000
     57  1000 ????	       00 c0	   BG_COLOR_GRAY =	%11000000
     58  1000 ????	       00 f0	   BG_COLOR_BLACK =	%11110000
     59  1000 ????						;BG_COLOR_BLACK      = %00
     60  1000 ????						;BG_COLOR_GREY       = %01
     61  1000 ????						;BG_COLOR_BLUE       = %10
     62  1000 ????						;BG_COLOR_GREEN      = %11
     63  1000 ????
     64  1000 ????						; Alternate (European) spellings...
     65  1000 ????	       00 40	   COLOUR_RED =	COLOR_RED
     66  1000 ????	       00 80	   COLOUR_BLUE =	COLOR_BLUE
     67  1000 ????	       00 00	   COLOUR_GREEN =	COLOR_GREEN
     68  1000 ????	       00 c0	   COLOUR_BACKGROUND =	COLOR_BACKGROUND
     69  1000 ????
     70  1000 ????						;-------------------------------------------------------------------------------
     71  1000 ????						; Hand Controller
     72  1000 ????
     73  1000 ????	       00 01	   CONTROL_RIGHT =	%00000001	;right
     74  1000 ????	       00 02	   CONTROL_LEFT =	%00000010	;left
     75  1000 ????	       00 04	   CONTROL_BACKWARD =	%00000100	;backward
     76  1000 ????	       00 08	   CONTROL_FORWARD =	%00001000	;forward
     77  1000 ????	       00 10	   CONTROL_CCW =	%00010000	;counterclockwise
     78  1000 ????	       00 20	   CONTROL_CW =	%00100000	;clockwise
     79  1000 ????	       00 40	   CONTROL_PULL =	%01000000	;pull up
     80  1000 ????	       00 80	   CONTROL_PUSH =	%10000000	;push down
     81  1000 ????
     82  1000 ????						;-------------------------------------------------------------------------------
     83  1000 ????						; Console Buttons
     84  1000 ????
     85  1000 ????	       00 01	   CONSOLE_1  =	%00000001	;button 1
     86  1000 ????	       00 02	   CONSOLE_2  =	%00000010	;button 2
     87  1000 ????	       00 04	   CONSOLE_3  =	%00000100	;button 3
     88  1000 ????	       00 08	   CONSOLE_4  =	%00001000	;button 4
     89  1000 ????
     90  1000 ????						;-------------------------------------------------------------------------------
     91  1000 ????						; Alternate Register Names
     92  1000 ????
     93  1000 ????	       00 00	   r0	      =	0
     94  1000 ????	       00 01	   r1	      =	1
     95  1000 ????	       00 02	   r2	      =	2
     96  1000 ????	       00 03	   r3	      =	3
     97  1000 ????	       00 04	   r4	      =	4
     98  1000 ????	       00 05	   r5	      =	5
     99  1000 ????	       00 06	   r6	      =	6
    100  1000 ????	       00 07	   r7	      =	7
    101  1000 ????	       00 08	   r8	      =	8
    102  1000 ????	       00 09	   r9	      =	9
    103  1000 ????	       00 0a	   r10	      =	10
    104  1000 ????	       00 0b	   r11	      =	11
    105  1000 ????
    106  1000 ????						;-------------------------------------------------------------------------------
    107  1000 ????						; Mnemonics for the BT Instruction
    108  1000 ????						;  "If any of these flags are true, then branch"
    109  1000 ????	       00 00	   never      =	0
    110  1000 ????	       00 01	   ifS	      =	1
    111  1000 ????	       00 02	   ifC	      =	2
    112  1000 ????	       00 03	   ifCS       =	3
    113  1000 ????	       00 04	   ifZ	      =	4
    114  1000 ????	       00 05	   ifZS       =	5
    115  1000 ????	       00 06	   ifZC       =	6
    116  1000 ????	       00 07	   ifZCS      =	7
    117  1000 ????
    118  1000 ????						;-------------------------------------------------------------------------------
    119  1000 ????						; Mnemonics for the BF Instruction
    120  1000 ????						;  "If all of these flags are false, then branch"
    121  1000 ????	       00 00	   always     =	$0
    122  1000 ????	       00 01	   ifNotS     =	$1
    123  1000 ????	       00 02	   ifNotC     =	$2
    124  1000 ????	       00 03	   ifNotCS    =	$3
    125  1000 ????	       00 04	   ifNotZ     =	$4
    126  1000 ????	       00 05	   ifNotZS    =	$5
    127  1000 ????	       00 06	   ifNotZC    =	$6
    128  1000 ????	       00 07	   ifNotZCS   =	$7
    129  1000 ????	       00 08	   ifNotO     =	$8
    130  1000 ????	       00 09	   ifNotOS    =	$9
    131  1000 ????	       00 0a	   ifNotOC    =	$A
    132  1000 ????	       00 0b	   ifNotOCS   =	$B
    133  1000 ????	       00 0c	   ifNotOZ    =	$C
    134  1000 ????	       00 0d	   ifNotOZS   =	$D
    135  1000 ????	       00 0e	   ifNotOZC   =	$E
    136  1000 ????	       00 0f	   ifNotOZCS  =	$F
    137  1000 ????
    138  1000 ????						;------------------------
    139  1000 ????						; Schach RAM
    140  1000 ????						;------------------------
    141  1000 ????	       28 00	   ram	      =	$2800	;location of RAM available in Schach cartridge
    142  1000 ????
    143  1000 ????						;===================================================================
    144  1000 ????						; M A C R O S
    145  1000 ????						;===================================================================
    146  1000 ????
    147  1000 ????						;-------------------------
    148  1000 ????						; CARTRIDGE_START
    149  1000 ????						; Original Author: Sean Riddle
    150  1000 ????						; Inserts the $55 that signals a valid Channel F cartridge and an
    151  1000 ????						; unused byte, which places the VES at the cartridge entry point, $802.
    152  1000 ????
    153  1000 ????				      MAC	cartridge_start
    154  1000 ????				      .byte	$55, $00	; valid cart indicator, unused byte
    155  1000 ????				      ENDM
    156  1000 ????
    157  1000 ????						;-------------------------
    158  1000 ????						; CARTRIDGE_INIT
    159  1000 ????						; Original Author: Sean Riddle
    160  1000 ????						; Initalizes the hardware and clears the complement flag.
    161  1000 ????
    162  1000 ????				      MAC	cartridge_init
    163  1000 ????						; initalize the hardware
    164  1000 ????				      lis	0
    165  1000 ????				      outs	1
    166  1000 ????				      outs	4
    167  1000 ????				      outs	5
    168  1000 ????				      outs	0
    169  1000 ????
    170  1000 ????						; clear the complement flag (r32)
    171  1000 ????				      lisu	4
    172  1000 ????				      lisl	0
    173  1000 ????				      lr	S, A
    174  1000 ????				      ENDM
    175  1000 ????
    176  1000 ????						;-------------------------
    177  1000 ????						; PROMPTS_NO_T
    178  1000 ????						; Original Author: Sean Riddle
    179  1000 ????						; This code functions the same as the "prompts" section of the BIOS,
    180  1000 ????						; but this code doesn't have a "T?" prompt, so it's useful in games that
    181  1000 ????						; don't have time limits or settings.
    182  1000 ????
    183  1000 ????				      MAC	prompts_not
    184  1000 ????			   prompts    SUBROUTINE
    185  1000 ????				      LR	K,P	;
    186  1000 ????				      PI	BIOS_PUSH_K	;
    187  1000 ????			   .prompts2  LI	$85	; red 5 (S)
    188  1000 ????				      LR	$0,A	;
    189  1000 ????				      PI	prompt	;
    190  1000 ????				      LR	A,$4	;
    191  1000 ????				      CI	$08	; is it button 4, Start?
    192  1000 ????				      BF	$4,.notbut4	; no, check others
    193  1000 ????			   .notbut2
    194  1000 ????				      PI	popk	; yes, return
    195  1000 ????				      PK		;
    196  1000 ????
    197  1000 ????			   .notbut4   CI	$02	; is it button 2, Mode?
    198  1000 ????				      BF	$4,.notbut2	;
    199  1000 ????				      LI	$8e	; red M
    200  1000 ????				      LR	$0,A	;
    201  1000 ????				      PI	prompt	;
    202  1000 ????				      LISU	3	;
    203  1000 ????				      LISL	6	;
    204  1000 ????				      LR	A,(IS)	;
    205  1000 ????				      as	4	;add the mode to the game #
    206  1000 ????				      LR	(IS),A	;
    207  1000 ????				      BF	$0,.prompts2	;
    208  1000 ????				      ENDM
    209  1000 ????
    210  1000 ????						;-------------------------
    211  1000 ????						; SETISAR
    212  1000 ????						; Original Author: Blackbird
    213  1000 ????						; Sets the ISAR to a register number, using lisu and lisl
    214  1000 ????
    215  1000 ????				      MAC	setisar
    216  1000 ????				      lisu	[[{1}] >> 3]
    217  1000 ????				      lisl	[[{1}] & %111]
    218  1000 ????				      ENDM
    219  1000 ????
    220  1000 ????						;-------------------------
    221  1000 ????						; SETISARU / SETISARL
    222  1000 ????						; Sets the corresponding ISAR octal nybble to the corresponding octal nybble
    223  1000 ????						; of the input argument
    224  1000 ????
    225  1000 ????				      MAC	setisaru
    226  1000 ????				      lisu	[[[{1}] >> 3] & %111]
    227  1000 ????				      ENDM
    228  1000 ????
    229  1000 ????				      MAC	setisarl
    230  1000 ????				      lisl	[[{1}] & %111]
    231  1000 ????				      ENDM
    232  1000 ????
    233  1000 ????						;--------------------------
    234  1000 ????						; neg
    235  1000 ????						; Takes the 2's complement of the accumulator
    236  1000 ????
    237  1000 ????				      MAC	neg
    238  1000 ????				      com
    239  1000 ????				      inc
    240  1000 ????				      ENDM
    241  1000 ????
    242  1000 ????						;-------------------------------------------------------------------------------
    243  1000 ????						; The following required for back-compatibility with code which does not use
    244  1000 ????						; segments.
    245  1000 ????
    246  1000 ????				      SEG
    247  1000 ????
    248  1000 ????						; EOF
------- FILE dodge_it.asm
     28  1000 ????
     29  1000 ????	       00 00	   Reset      equ	$0000
     30  1000 ????
     31  1000 ????						; Global Variables / Registers
     32  1000 ????
     33  1000 ????						; Main-Level Registers
     34  1000 ????	       00 0b	   main.curBall =	$B
     35  1000 ????
     36  1000 ????						; Balls
     37  1000 ????	       00 10	   balls.xpos =	$10	; Array
     38  1000 ????	       00 0b	   balls.arraySize =	$0B	; Constant
     39  1000 ????	       00 26	   balls.velocity =	$26
     40  1000 ????
     41  1000 ????						; Arena Bounds
     42  1000 ????	       00 30	   bounds.rightEnemy =	060
     43  1000 ????	       00 31	   bounds.rightPlayer =	061
     44  1000 ????	       00 32	   bounds.left =	062
     45  1000 ????	       00 33	   bounds.bottomEnemy =	063
     46  1000 ????	       00 34	   bounds.bottomPlayer =	064
     47  1000 ????	       00 35	   bounds.top =	065
     48  1000 ????
     49  1000 ????						; Timer
     50  1000 ????	       00 36	   timer.hiByte =	066
     51  1000 ????	       00 37	   timer.loByte =	067
     52  1000 ????
     53  1000 ????						; Game mode
     54  1000 ????	       00 3d	   gameMode   =	075
     55  1000 ????	       00 02	   mode.speedMask =	$02
     56  1000 ????	       00 01	   mode.2playerMask =	$01
     57  1000 ????
     58  1000 ????
     59  1000 ????						;--------------------
     60  1000 ????						; Constants
     61  1000 ????	       00 02	   MAX_PLAYERS =	2
     62  1000 ????
     63  1000 ????						; Graphics
     64  1000 ????	       00 7d	   gfx.attributeCol =	$7d
     65  1000 ????	       00 02	   gfx.attributeWidth =	2
     66  1000 ????	       00 80	   gfx.screenWidth =	$80
     67  1000 ????	       00 40	   gfx.screenHeight =	$40
     68  1000 ????
     69  1000 ????						;--
     70  1000 ????
     71  0800					      org	$0800
     72  0800
     73  0800		       55 2b	   CartridgeHeader db.b	$55, $2b
     74  0802		       29 0c d0    CartridgeEntry JMP	initRoutine
     75  0805
     76  0805							; Graphics data
     77  0805				   graphicsData
     78  0805							;0,1
     79  0805		       72		      db.b	%01110010
     80  0806		       56		      db.b	%01010110
     81  0807		       52		      db.b	%01010010
     82  0808		       52		      db.b	%01010010
     83  0809		       77		      db.b	%01110111
     84  080a							; 2, 3
     85  080a		       77		      db.b	%01110111
     86  080b		       11		      db.b	%00010001
     87  080c		       73		      db.b	%01110011
     88  080d		       41		      db.b	%01000001
     89  080e		       77		      db.b	%01110111
     90  080f							; 4, 5
     91  080f		       57		      db.b	%01010111
     92  0810		       54		      db.b	%01010100
     93  0811		       77		      db.b	%01110111
     94  0812		       11		      db.b	%00010001
     95  0813		       17		      db.b	%00010111
     96  0814							; 6, 7
     97  0814		       47		      db.b	%01000111
     98  0815		       41		      db.b	%01000001
     99  0816		       71		      db.b	%01110001
    100  0817		       51		      db.b	%01010001
    101  0818		       71		      db.b	%01110001
    102  0819							; 8, 9
    103  0819		       77		      db.b	%01110111
    104  081a		       55		      db.b	%01010101
    105  081b		       77		      db.b	%01110111
    106  081c		       51		      db.b	%01010001
    107  081d		       71		      db.b	%01110001
    108  081e							; G ?
    109  081e		       ff		      db.b	%11111111
    110  081f		       81		      db.b	%10000001
    111  0820		       b2		      db.b	%10110010
    112  0821		       90		      db.b	%10010000
    113  0822		       f2		      db.b	%11110010
    114  0823							; F A
    115  0823		       77		      db.b	%01110111
    116  0824		       45		      db.b	%01000101
    117  0825		       77		      db.b	%01110111
    118  0826		       45		      db.b	%01000101
    119  0827		       45		      db.b	%01000101
    120  0828							; S T
    121  0828		       77		      db.b	%01110111
    122  0829		       42		      db.b	%01000010
    123  082a		       72		      db.b	%01110010
    124  082b		       12		      db.b	%00010010
    125  082c		       72		      db.b	%01110010
    126  082d
    127  082d							; Delay table A (easy)
    128  082d				   delayTableA
    129  082d		       19 16 13 11*	      db.b	$19, $16, $13, $11, $0e, $0c, $0a, $08, $06, $03, $01
    130  0838
    131  0838							; Delay table B (pro)
    132  0838				   delayTableB
    133  0838		       0b 0a 09 08*	      db.b	$0b, $0a, $09, $08, $07, $06, $05, $04, $03, $02, $01
    134  0843
    135  0843							; Game mode table ?
    136  0843				   A0843
    137  0843		       c0 30 0c 03*	      db.b	$C0, $30, $0C, $03, $FC	; 0843 c0 30 0c 03 fc
    138  0848
    139  0848							; Playfield bounds ? Unused ??
    140  0848				   A0848
    141  0848		       00 00 12 0b*	      db.b	$00, $00, $12, $0B, $0B, $06, $02, $01	; 0848 00 00 12 0b 0b 06 02 01
    142  0850
    143  0850				   ballColors		; blue, green, red ?
    144  0850		       40 c0 80 	      db.b	$40, $C0, $80	; 0850 40 c0 80
    145  0853
    146  0853				   A0853		;Used by menu...
    147  0853		       00 01 02 03*	      db.b	$00, $01, $02, $03, $03	; 0853 00 01
    148  0858
    149  0858							; --?
    150  0858
    151  0858							;----------------------------
    152  0858							; leaf-function : draw
    153  0858							;  This function has 2 entry points
    154  0858							;  If the second entry point is used, then draw.glyph should be either $80 or $C0
    155  0858							;  Given the control codes in draw.glyph, this routine should support up to 64 different
    156  0858							;  characters.
    157  0858							;
    158  0858							; Bitmasks for draw.glyph
    159  0858		       00 80	   draw.drawRect =	$80
    160  0858		       00 c0	   draw.drawAttribute =	$C0
    161  0858							; Local constants
    162  0858		       00 c0	   draw.colorMask =	$C0
    163  0858		       00 c0	   draw.soundMask =	$C0
    164  0858		       00 3f	   draw.noSoundMask =	$3F
    165  0858							; Args:
    166  0858		       00 00	   draw.glyph =	0	; r0 - Glyph
    167  0858		       00 01	   draw.xpos  =	1	; r1 - X pos
    168  0858		       00 02	   draw.ypos  =	2	; r2 - Y pos & color (upper 2 bits)
    169  0858		       00 04	   draw.width =	4	; r4 - Width
    170  0858		       00 05	   draw.height =	5	; r5 - Height
    171  0858							; Locals
    172  0858		       00 03	   draw.data  =	3	; r3 as data
    173  0858		       00 06	   draw.xcount =	6	; r6 as h_count
    174  0858		       00 07	   draw.ycount =	7	; r7 as v_count
    175  0858		       00 08	   draw.temp  =	8	; For color and data counter
    176  0858
    177  0858							; Entry point for drawing a glyph
    178  0858				   drawGlyph
    179  0858							; Get the starting address of the desired glyph
    180  0858							; dc = graphicsData + glyph/2 + (glyph/2)*4
    181  0858		       2a 08 05 	      DCI	graphicsData	; 0858 2a 08 05
    182  085b		       40		      LR	A, draw.glyph	; 085b 40
    183  085c		       12		      SR	1	; 085c 12
    184  085d		       58		      LR	draw.temp, A	; 085d 58
    185  085e		       13		      SL	1	; 085e 13
    186  085f		       13		      SL	1	; 085f 13
    187  0860		       c8		      AS	draw.temp	; 0860 c8
    188  0861		       8e		      ADC		; 0861 8e
    189  0862
    190  0862							; Entry point for drawing a box
    191  0862				   drawBox
    192  0862							; xcount = width
    193  0862							; ycount = height
    194  0862		       44		      LR	A, draw.width	; 0862 44
    195  0863		       56		      LR	draw.xcount, A	; 0863 56
    196  0864		       45		      LR	A, draw.height	; 0864 45
    197  0865		       57		      LR	draw.ycount, A	; 0865 57
    198  0866
    199  0866							; Do one row
    200  0866				   draw.doRow
    201  0866							; Mask out row, put color in r8
    202  0866		       42		      LR	A, draw.ypos	; 0866 42
    203  0867		       21 c0		      NI	draw.colorMask	; 0867 21 c0
    204  0869		       58		      LR	draw.temp, A	; 0869 58
    205  086a							; Mask out sound, put row in r3
    206  086a		       42		      LR	A, draw.ypos	; 086a 42
    207  086b		       18		      COM		; 086b 18
    208  086c		       21 3f		      NI	draw.noSoundMask	; 086c 21 3f
    209  086e		       53		      LR	draw.data, A	; 086e 53
    210  086f							; Preserve sound, write row to port 5
    211  086f		       a5		      INS	5	; 086f a5
    212  0870		       21 c0		      NI	draw.soundMask	; 0870 21 c0
    213  0872		       c3		      AS	draw.data	; 0872 c3
    214  0873		       b5		      OUTS	5	; 0873 b5
    215  0874
    216  0874							; If glyph (r0) is negative, jump ahead
    217  0874		       70		      LIS	$0	; 0874 70
    218  0875		       c0		      AS	draw.glyph	; 0875 c0
    219  0876		       20 ff		      LI	$ff	; 0876 20 ff
    220  0878		       91 09		      BM	draw.label_1	; 0878 91 09
    221  087a							; Load data into r3
    222  087a		       16		      LM		; 087a 16
    223  087b		       53		      LR	draw.data, A	; 087b 53
    224  087c							; If glyph number is even, jump ahead
    225  087c		       71		      LIS	$1	; 087c 71
    226  087d		       f0		      NS	draw.glyph	; 087d f0
    227  087e		       84 04		      BZ	draw.doPixel	; 087e 84 04
    228  0880							; else, r3 = r3 << 4
    229  0880		       43		      LR	A, draw.data	; 0880 43
    230  0881		       15		      SL	4	; 0881 15
    231  0882				   draw.label_1
    232  0882		       53		      LR	draw.data, A	; 0882 53
    233  0883
    234  0883				   draw.doPixel
    235  0883							; port 4 = xpos
    236  0883		       41		      LR	A, draw.xpos	; 0883 41
    237  0884		       18		      COM		; 0884 18
    238  0885		       b4		      OUTS	4	; 0885 b4
    239  0886
    240  0886							; // Set the output color
    241  0886							; if(draw.data(MSB) == 1)
    242  0886							;  port 1 = draw.temp & draw.colorMask
    243  0886							; else
    244  0886							;  port 1 = BG_COLOR & draw.colorMask
    245  0886		       70		      LIS	$0	; 0886 70
    246  0887		       c3		      AS	draw.data	; 0887 c3
    247  0888		       48		      LR	A, draw.temp	; 0888 48
    248  0889		       91 02		      BM	draw.label_2	; 0889 91 02
    249  088b		       70		      LIS	$0	; 088b 70
    250  088c				   draw.label_2
    251  088c		       18		      COM		; 088c 18
    252  088d		       21 c0		      NI	draw.colorMask	; 088d 21 c0
    253  088f		       b1		      OUTS	1	; 088f b1
    254  0890
    255  0890							; // Left-shift data, while 1-padding it
    256  0890							; data = (data << 1) + 1
    257  0890		       43		      LR	A, draw.data	; 0890 43
    258  0891		       13		      SL	1	; 0891 13
    259  0892		       1f		      INC		; 0892 1f
    260  0893		       53		      LR	draw.data, A	; 0893 53
    261  0894
    262  0894							; If bit 6 of glyph is (not?) set, skip ahead
    263  0894		       40		      LR	A, draw.glyph	; 0894 40
    264  0895		       13		      SL	1	; 0895 13
    265  0896		       81 04		      BP	draw.label_3	; 0896 81 04
    266  0898							; Else, shift color left
    267  0898		       48		      LR	A, draw.temp	; 0898 48
    268  0899		       13		      SL	1	; 0899 13
    269  089a		       58		      LR	draw.temp, A	; 089a 58
    270  089b
    271  089b				   draw.label_3
    272  089b							; Activate VRAM write
    273  089b		       20 60		      LI	$60	; 089b 20 60
    274  089d		       b0		      OUTS	0	; 089d b0
    275  089e		       20 50		      LI	$50	; 089e 20 50
    276  08a0		       b0		      OUTS	0	; 08a0 b0
    277  08a1
    278  08a1							; xpos++
    279  08a1		       41		      LR	A, draw.xpos	; 08a1 41
    280  08a2		       1f		      INC		; 08a2 1f
    281  08a3		       51		      LR	draw.xpos, A	; 08a3 51
    282  08a4
    283  08a4							; Delay loop
    284  08a4		       74		      LIS	$4	; 08a4 74
    285  08a5				   draw.delay
    286  08a5		       24 ff		      AI	$ff	; 08a5 24 ff
    287  08a7		       94 fd		      BNZ	draw.delay	; 08a7 94 fd
    288  08a9
    289  08a9							; xcount--
    290  08a9		       36		      DS	draw.xcount	; 08a9 36
    291  08aa							; if(xcount != 0) goto doPixel
    292  08aa		       94 d8		      BNZ	draw.doPixel	; 08aa 94 d8
    293  08ac
    294  08ac							; ypos++
    295  08ac		       42		      LR	A, draw.ypos	; 08ac 42
    296  08ad		       1f		      INC		; 08ad 1f
    297  08ae		       52		      LR	draw.ypos, A	; 08ae 52
    298  08af
    299  08af							; // Reset x counters
    300  08af							; xcount = width
    301  08af							; xpos = xpos - width
    302  08af		       44		      LR	A, draw.width	; 08af 44
    303  08b0		       56		      LR	draw.xcount,A	; 08b0 56
    304  08b1							; Reset x_pos
    305  08b1		       18		      COM		; 08b1 18
    306  08b2		       1f		      INC		; 08b2 1f
    307  08b3		       c1		      AS	draw.xpos	; 08b3 c1
    308  08b4		       51		      LR	draw.xpos, A	; 08b4 51
    309  08b5
    310  08b5							; ycount--
    311  08b5		       37		      DS	draw.ycount	; 08b5 37
    312  08b6							; // if(ycount != 0) goto doRow
    313  08b6		       94 af		      BNZ	draw.doRow	; 08b6 94 af
    314  08b8
    315  08b8							; // Reset ypos
    316  08b8							; ypos = ypos - height
    317  08b8		       45		      LR	A, draw.height	; 08b8 45
    318  08b9		       18		      COM		; 08b9 18
    319  08ba		       1f		      INC		; 08ba 1f
    320  08bb		       c2		      AS	draw.ypos	; 08bb c2
    321  08bc		       52		      LR	draw.ypos, A	; 08bc 52
    322  08bd
    323  08bd							; Clear ports
    324  08bd		       70		      LIS	$0	; 08bd 70
    325  08be		       b1		      OUTS	1	; 08be b1
    326  08bf		       b0		      OUTS	0	; 08bf b0
    327  08c0		       1c		      POP		; 08c0 1c
    328  08c1							;
    329  08c1							; end leaf-function draw
    330  08c1							;----------------------------
    331  08c1
    332  08c1							; Modifies the contents of o76 and o77
    333  08c1							; No input arguments
    334  08c1							; RNG (probably)
    335  08c1		       00 3e	   RNG.seedBottom =	076
    336  08c1		       00 3f	   RNG.seedTop =	077
    337  08c1							; Returns in registers
    338  08c1		       00 06	   RNG.regLo  =	$6
    339  08c1		       00 07	   RNG.regHi  =	$7
    340  08c1
    341  08c1							; Locals
    342  08c1		       00 08	   roll_RNG.tempISAR =	8	; r8 is used as temp ISAR
    343  08c1
    344  08c1				   roll_RNG
    345  08c1							; Save the ISAR in r8
    346  08c1		       0a		      LR	A,IS	; 08c1 0a
    347  08c2		       58		      LR	roll_RNG.tempISAR, A	; 08c2 58
    348  08c3							; r6 = o77*2 + o76
      0  08c3					      SETISAR	RNG.seedTop	; 08c3 67 6f
      1  08c3		       67		      lisu	[[RNG.seedTop] >> 3]
      2  08c4		       6f		      lisl	[[RNG.seedTop] & %111]
    350  08c5		       4e		      LR	A,(IS)-	; 08c5 4e
    351  08c6		       13		      SL	1	; 08c6 13
    352  08c7		       cd		      AS	(IS)+	; 08c7 cd
    353  08c8		       56		      LR	RNG.regLo, A	; 08c8 56
    354  08c9							; r7 = o77*2 ??
    355  08c9		       4c		      LR	A,(IS)	; 08c9 4c
    356  08ca		       cc		      AS	(IS)	; 08ca cc
    357  08cb		       57		      LR	RNG.regHi, A	; 08cb 57
    358  08cc							; r6 = r6*2 (+1 if o77*2 carried over) ?
    359  08cc		       1e		      LR	J,W	; 08cc 1e ; save status reg
    360  08cd		       46		      LR	A, RNG.regLo	; 08cd 46
    361  08ce		       13		      SL	1	; 08ce 13
    362  08cf		       1d		      LR	W,J	; 08cf 1d ; reload status reg
    363  08d0		       19		      LNK		; 08d0 19
    364  08d1		       56		      LR	RNG.regLo, A	; 08d1 56
    365  08d2							; r7 = r7*2
    366  08d2		       47		      LR	A, RNG.regHi	; 08d2 47
    367  08d3		       c7		      AS	RNG.regHi	; 08d3 c7
    368  08d4		       57		      LR	RNG.regHi, A	; 08d4 57
    369  08d5							; r6 = r6*2 (+1 if r7*2 carried over) ?
    370  08d5		       1e		      LR	J,W	; 08d5 1e
    371  08d6		       46		      LR	A, RNG.regLo	; 08d6 46
    372  08d7		       13		      SL	1	; 08d7 13
    373  08d8		       1d		      LR	W,J	; 08d8 1d
    374  08d9		       19		      LNK		; 08d9 19
    375  08da		       56		      LR	RNG.regLo, A	; 08da 56
    376  08db							; r7 = r7 + o77
    377  08db		       47		      LR	A, RNG.regHi	; 08db 47
    378  08dc		       ce		      AS	(IS)-	; 08dc ce
    379  08dd		       57		      LR	RNG.regHi, A	; 08dd 57
    380  08de							; r6 = r6 (+1 if r7+077 carried) + o76
    381  08de		       46		      LR	A, RNG.regLo	; 08de 46
    382  08df		       19		      LNK		; 08df 19
    383  08e0		       cd		      AS	(IS)+	; 08e0 cd
    384  08e1		       56		      LR	RNG.regLo, A	; 08e1 56
    385  08e2							; r7 = r7 + 0x19
    386  08e2							; o77 = the same
    387  08e2		       47		      LR	A, RNG.regHi	; 08e2 47
    388  08e3		       24 19		      AI	$19	; 08e3 24 19
    389  08e5		       57		      LR	RNG.regHi, A	; 08e5 57
    390  08e6		       5e		      LR	(IS)-,A	; 08e6 5e
    391  08e7							; r6 = r6 (+1 if r7+0x19 carried) + 0x36
    392  08e7							; o76 = the same
    393  08e7		       46		      LR	A, RNG.regLo	; 08e7 46
    394  08e8		       19		      LNK		; 08e8 19
    395  08e9		       24 36		      AI	$36	; 08e9 24 36
    396  08eb		       56		      LR	RNG.regLo, A	; 08eb 56
    397  08ec		       5d		      LR	(IS)+,A	; 08ec 5d
    398  08ed							; Reload ISAR
    399  08ed		       48		      LR	A, roll_RNG.tempISAR	; 08ed 48
    400  08ee		       0b		      LR	IS,A	; 08ee 0b
    401  08ef							; Return
    402  08ef		       1c		      POP		; 08ef 1c
    403  08f0
    404  08f0							; Menu
    405  08f0
    406  08f0							; Locals
    407  08f0		       af 00	   menu.waitTime =	$af00
    408  08f0		       00 00	   menu.buttons =	0
    409  08f0		       00 02	   menu.waitHi =	2
    410  08f0		       00 01	   menu.waitLo =	1
    411  08f0
    412  08f0				   menu
    413  08f0		       08		      LR	K,P	; 08f0 08
    414  08f1							; set lower byte of waitloop counter
    415  08f1		       70		      LIS	[<menu.waitTime]	; 08f1 70
    416  08f2		       51		      LR	menu.waitLo,A	; 08f2 51
    417  08f3							; clear console buttons, load default state
    418  08f3		       b0		      OUTS	0	; 08f3 b0
    419  08f4		       a0		      INS	0	; 08f4 a0
    420  08f5		       50		      LR	menu.buttons, A	; 08f5 50
    421  08f6							; set upper byte of waitloop counter
    422  08f6		       20 af		      LI	[>menu.waitTime]	; 08f6 20 af
    423  08f8		       52		      LR	menu.waitHi, A	; 08f8 52
    424  08f9
    425  08f9				   menu.pollInput
    426  08f9		       28 08 c1 	      PI	roll_RNG	; 08f9 28 08 c1
    427  08fc		       2a 08 53 	      DCI	A0853	; 08fc 2a 08 53
    428  08ff							; Read console buttons
    429  08ff		       70		      LIS	$0	; 08ff 70
    430  0900		       b0		      OUTS	0	; 0900 b0
    431  0901		       a0		      INS	0	; 0901 a0
    432  0902							; Check if different
    433  0902		       e0		      XS	menu.buttons	; 0902 e0
    434  0903							; if not, decrement waitloop
    435  0903		       84 03		      BZ	menu.wait	; 0903 84 03
    436  0905
    437  0905				   menu.exit
    438  0905		       50		      LR	$0,A	; 0905 50
    439  0906		       0c		      PK		; 0906 0c
    440  0907
    441  0907				   menu.wait
    442  0907		       31		      DS	menu.waitLo	; 0907 31
    443  0908		       94 f0		      BNZ	menu.pollInput	; 0908 94 f0
    444  090a		       32		      DS	menu.waitHi	; 090a 32
    445  090b		       94 ed		      BNZ	menu.pollInput	; 090b 94 ed
    446  090d							; Default to game mode 1 (1 player, easy)
    447  090d		       71		      LIS	$1	; 090d 71
    448  090e							; return
    449  090e		       90 f6		      BR	menu.exit	; 090e 90 f6
    450  0910							;
    451  0910							; end mid-function menu
    452  0910							;----------------------------
    453  0910
    454  0910							; Read controllers
    455  0910							; Args
    456  0910							; Locals
    457  0910							; r0
    458  0910							; Return
    459  0910		       00 38	   controller1 =	070	; Controller 1
    460  0910		       00 39	   controller2 =	071	; Controller 2
    461  0910
    462  0910				   readControllers
      0  0910					      SETISAR	controller1	; 0910 67 68
      1  0910		       67		      lisu	[[controller1] >> 3]
      2  0911		       68		      lisl	[[controller1] & %111]
    464  0912							; Clear controllers
    465  0912		       70		      LIS	$0	; 0912 70
    466  0913		       b1		      OUTS	1	; 0913 b1
    467  0914		       b4		      OUTS	4	; 0914 b4
    468  0915							; Save controller 1 in o70
    469  0915		       a1		      INS	1	; 0915 a1
    470  0916		       5d		      LR	(IS)+,A	; 0916 5d
    471  0917							; Save controller 2 in 071
    472  0917		       a4		      INS	4	; 0917 a4
    473  0918		       5e		      LR	(IS)-,A	; 0918 5e
    474  0919							; Add controller 1 & 2
    475  0919		       cc		      AS	(IS)	; 0919 cc
    476  091a							; Take the two's complement
    477  091a		       1f		      INC		; 091a 1f
    478  091b		       18		      COM		; 091b 18
    479  091c							; If the result is zero, return
    480  091c		       84 06		      BZ	A0923	; 091c 84 06
    481  091e							; else, shuffle RNG ?
    482  091e							; switch to o77
      0  091e					      SETISARL	RNG.seedTop	; 091e 6f
      1  091e		       6f		      lisl	[[RNG.seedTop] & %111]
    484  091f		       71		      LIS	$1	; 091f 71
    485  0920							; o77 = o77 + 1
    486  0920		       cc		      AS	(IS)	; 0920 cc
    487  0921		       5e		      LR	(IS)-,A	; 0921 5e
    488  0922							; o76--
    489  0922		       3c		      DS	(IS)	; 0922 3c
    490  0923							; Return
    491  0923		       1c	   A0923      POP		; 0923 1c
    492  0924
    493  0924							; HandlePlayerMovement
    494  0924				   playerHandler
    495  0924		       08		      LR	K,P	; 0924 08
    496  0925		       28 09 10 	      PI	readControllers	; 0925 28 09 10
    497  0928							; Check if LSB of RNG is set
      0  0928					      SETISAR	RNG.seedTop	; 0928 67 6f
      1  0928		       67		      lisu	[[RNG.seedTop] >> 3]
      2  0929		       6f		      lisl	[[RNG.seedTop] & %111]
    499  092a		       71		      LIS	$1	; 092a 71
    500  092b		       fc		      NS	(IS)	; 092b fc
    501  092c		       70		      LIS	$0	; 092c 70
    502  092d							; skip ahead if it is not set
    503  092d		       94 02		      BNZ	A0930	; 092d 94 02
    504  092f
    505  092f		       71		      LIS	$1	; 092f 71
    506  0930		       5b	   A0930      LR	$b,A	; 0930 5b
    507  0931							; r8 = 2
    508  0931		       72		      LIS	$2	; 0931 72
    509  0932		       58		      LR	$8,A	; 0932 58
    510  0933							; r0 = 0
    511  0933		       70	   A0933      LIS	$0	; 0933 70
    512  0934		       50		      LR	$0,A	; 0934 50
    513  0935							; r1 = xpos[r11]
    514  0935		       4b		      LR	A,$b	; 0935 4b
    515  0936		       24 10		      AI	balls.xpos	; 0936 24 10
    516  0938		       0b		      LR	IS,A	; 0938 0b
    517  0939		       4c		      LR	A,(IS)	; 0939 4c
    518  093a		       51		      LR	$1,A	; 093a 51
    519  093b							; r2 = ypos[r11]
    520  093b		       0a		      LR	A,IS	; 093b 0a
    521  093c		       24 0b		      AI	balls.arraySize	; 093c 24 0b
    522  093e		       0b		      LR	IS,A	; 093e 0b
    523  093f		       4c		      LR	A,(IS)	; 093f 4c
    524  0940		       52		      LR	$2,A	; 0940 52
    525  0941							; if((r11 & 0x01) == 0)
    526  0941							;  ISAR = 70 (controller 1 ?)
    527  0941							; else
    528  0941							;  ISAR = 71 (controller 2 ?)
      0  0941					      SETISARU	controller1	; 0941 67
      1  0941		       67		      lisu	[[[controller1] >> 3] & %111]
    530  0942		       71		      LIS	$1	; 0942 71
    531  0943		       fb		      NS	main.curBall	; 0943 fb
      0  0944					      SETISARL	controller2	; 0944 69
      1  0944		       69		      lisl	[[controller2] & %111]
    533  0945		       94 02		      BNZ	A0948	; 0945 94 02
      0  0947					      SETISARL	controller1	; 0947 68
      1  0947		       68		      lisl	[[controller1] & %111]
    535  0948							; Check if a direction is pressed
    536  0948		       71	   A0948      LIS	$1	; 0948 71
    537  0949		       fc		      NS	(IS)	; 0949 fc
    538  094a		       94 06		      BNZ	A0951	; 094a 94 06
    539  094c							;
    540  094c		       41		      LR	A,$1	; 094c 41
    541  094d		       21 7f		      NI	$7f	; 094d 21 7f
    542  094f		       90 08		      BR	A0958	; 094f 90 08
    543  0951							; Check if a different direction is pressed
    544  0951		       72	   A0951      LIS	$2	; 0951 72
    545  0952		       fc		      NS	(IS)	; 0952 fc
    546  0953		       94 08		      BNZ	A095c	; 0953 94 08
    547  0955		       41		      LR	A,$1	; 0955 41
    548  0956		       22 80		      OI	$80	; 0956 22 80
    549  0958		       51	   A0958      LR	$1,A	; 0958 51
    550  0959		       7c		      LIS	$c	; 0959 7c
    551  095a		       fa		      NS	$a	; 095a fa
    552  095b		       50		      LR	$0,A	; 095b 50
    553  095c							; Check if a direction is pressed
    554  095c		       74	   A095c      LIS	$4	; 095c 74
    555  095d		       fc		      NS	(IS)	; 095d fc
    556  095e		       94 06		      BNZ	A0965	; 095e 94 06
    557  0960		       42		      LR	A,$2	; 0960 42
    558  0961		       21 3f		      NI	$3f	; 0961 21 3f
    559  0963		       90 08		      BR	A096c	; 0963 90 08
    560  0965							; Check if a direction is pressed
    561  0965		       78	   A0965      LIS	$8	; 0965 78
    562  0966		       fc		      NS	(IS)	; 0966 fc
    563  0967		       94 0b		      BNZ	A0973	; 0967 94 0b
    564  0969		       42		      LR	A,$2	; 0969 42
    565  096a		       22 80		      OI	$80	; 096a 22 80
    566  096c		       52	   A096c      LR	$2,A	; 096c 52
    567  096d							; ??
    568  096d		       7c		      LIS	$c	; 096d 7c
    569  096e		       fa		      NS	$a	; 096e fa
    570  096f		       12		      SR	1	; 096f 12
    571  0970		       12		      SR	1	; 0970 12
    572  0971		       c0		      AS	$0	; 0971 c0
    573  0972		       50		      LR	$0,A	; 0972 50
    574  0973		       40	   A0973      LR	A,$0	; 0973 40
    575  0974		       15		      SL	4	; 0974 15
    576  0975		       c0		      AS	$0	; 0975 c0
    577  0976		       50		      LR	$0,A	; 0976 50
    578  0977							; What ?
    579  0977		       28 09 a2 	      PI	saveBall	; 0977 28 09 a2
    580  097a		       71		      LIS	$1	; 097a 71
    581  097b		       fb		      NS	$b	; 097b fb
    582  097c		       70		      LIS	$0	; 097c 70
    583  097d		       94 02		      BNZ	A0980	; 097d 94 02
    584  097f		       71		      LIS	$1	; 097f 71
    585  0980		       5b	   A0980      LR	$b,A	; 0980 5b
    586  0981		       38		      DS	$8	; 0981 38
    587  0982		       94 b0		      BNZ	A0933	; 0982 94 b0
    588  0984		       09		      LR	P,K	; 0984 09
    589  0985		       1c		      POP		; 0985 1c
    590  0986							; --?
    591  0986
    592  0986							; Variable delay function
    593  0986							; Args
    594  0986							; Use this if entering via delay.viaLookup
    595  0986		       00 00	   delay.index =	0
    596  0986							; Use this if entering via delay.variable
    597  0986		       00 00	   delay.count =	0
    598  0986							; Locals
    599  0986		       00 03	   delay.tempISAR =	3
    600  0986
    601  0986				   delay.viaLookup
    602  0986							; // Get the appropriate delay count from an array in ROM.
    603  0986							; // Also, save the ISAR during this so it doesn't get clobbered
    604  0986							; if(gameMode & speedMask == 0)
    605  0986							;  count = delayTableA[index]
    606  0986							; else
    607  0986							;  count = delayTableB[index]
    608  0986		       2a 08 2d 	      DCI	delayTableA	; 0986 2a 08 2d
    609  0989
    610  0989							; Save the ISAR
    611  0989		       0a		      LR	A,IS	; 0989 0a
    612  098a		       53		      LR	delay.tempISAR, A	; 098a 53
    613  098b
      0  098b					      SETISAR	gameMode	; 098b 67 6d
      1  098b		       67		      lisu	[[gameMode] >> 3]
      2  098c		       6d		      lisl	[[gameMode] & %111]
    615  098d		       72		      LIS	mode.speedMask	; 098d 72
    616  098e		       fc		      NS	(IS)	; 098e fc
    617  098f
    618  098f							; Restore the ISAR
    619  098f		       43		      LR	A, delay.tempISAR	; 098f 43
    620  0990		       0b		      LR	IS, A	; 0990 0b
    621  0991
    622  0991		       84 04		      BZ	delay.loadData	; 0991 84 04
    623  0993		       2a 08 38 	      DCI	delayTableB	; 0993 2a 08 38
    624  0996
    625  0996				   delay.loadData
    626  0996		       40		      LR	A, delay.index	; 0996 40
    627  0997		       8e		      ADC		; 0997 8e
    628  0998		       16		      LM		; 0998 16
    629  0999		       50		      LR	delay.count, A	; 0999 50
    630  099a
    631  099a				   delay.variable
    632  099a		       70		      LIS	$0	; 099a 70
    633  099b				   delay.inner
    634  099b		       1f		      INC		; 099b 1f
    635  099c		       94 fe		      BNZ	delay.inner	; 099c 94 fe
    636  099e		       30		      DS	delay.count	; 099e 30
    637  099f		       94 fa		      BNZ	delay.variable	; 099f 94 fa
    638  09a1							; Return
    639  09a1		       1c		      POP		; 09a1 1c
    640  09a2
    641  09a2							; Args
    642  09a2							; r0 = velocity
    643  09a2							; r1 = xpos
    644  09a2							; r2 = ypos
    645  09a2							; rb = index
    646  09a2							; Clobber
    647  09a2							; r3 ?
    648  09a2				   saveBall
    649  09a2							; xpos[b] = r1
    650  09a2		       20 10		      LI	balls.xpos	; 09a2 20 10
    651  09a4		       cb		      AS	main.curBall	; 09a4 cb
    652  09a5		       0b		      LR	IS,A	; 09a5 0b
    653  09a6		       41		      LR	A,$1	; 09a6 41
    654  09a7		       5c		      LR	(IS),A	; 09a7 5c
    655  09a8							; ypos[b] = r2
    656  09a8		       0a		      LR	A,IS	; 09a8 0a
    657  09a9		       24 0b		      AI	balls.arraySize	; 09a9 24 0b
    658  09ab		       0b		      LR	IS,A	; 09ab 0b
    659  09ac		       42		      LR	A,$2	; 09ac 42
    660  09ad		       5c		      LR	(IS),A	; 09ad 5c
    661  09ae							; set velocity according to some formula
    662  09ae		       4b		      LR	A, main.curBall	; 09ae 4b
    663  09af		       12		      SR	1	; 09af 12
    664  09b0		       24 26		      AI	balls.velocity	; 09b0 24 26
    665  09b2		       0b		      LR	IS,A	; 09b2 0b
    666  09b3		       71		      LIS	$1	; 09b3 71
    667  09b4		       fb		      NS	main.curBall	; 09b4 fb
    668  09b5		       7f		      LIS	$f	; 09b5 7f
    669  09b6		       94 02		      BNZ	A09b9	; 09b6 94 02
    670  09b8		       18		      COM		; 09b8 18
    671  09b9				   A09b9
    672  09b9		       53		      LR	$3,A	; 09b9 53
    673  09ba		       18		      COM		; 09ba 18
    674  09bb		       fc		      NS	(IS)	; 09bb fc
    675  09bc		       5c		      LR	(IS),A	; 09bc 5c
    676  09bd		       40		      LR	A,$0	; 09bd 40
    677  09be		       f3		      NS	$3	; 09be f3
    678  09bf		       cc		      AS	(IS)	; 09bf cc
    679  09c0		       5c		      LR	(IS),A	; 09c0 5c
    680  09c1							; exit
    681  09c1		       1c		      POP		; 09c1 1c
    682  09c2
    683  09c2							; Spawn ball?
    684  09c2							; Args
    685  09c2
    686  09c2							; Locals
    687  09c2
    688  09c2							; Returns
    689  09c2
    690  09c2				   maybeSpawn
    691  09c2		       08		      LR	K,P	; 09c2 08
    692  09c3				   maybeSpawn.reroll
    693  09c3							; keep rerolling RNG until r6 and r7 are in some range
    694  09c3							; r1 = r6, r2 = r7
    695  09c3		       28 08 c1 	      PI	roll_RNG	; 09c3 28 08 c1
    696  09c6		       46		      LR	A, RNG.regLo	; 09c6 46
    697  09c7		       25 10		      CI	$10	; 09c7 25 10
    698  09c9		       82 f9		      BC	maybeSpawn.reroll	; 09c9 82 f9
    699  09cb		       25 57		      CI	$57	; 09cb 25 57
    700  09cd		       92 f5		      BNC	maybeSpawn.reroll	; 09cd 92 f5
    701  09cf		       51		      LR	$1,A	; 09cf 51
    702  09d0		       47		      LR	A, RNG.regHi	; 09d0 47
    703  09d1		       25 10		      CI	$10	; 09d1 25 10
    704  09d3		       82 ef		      BC	maybeSpawn.reroll	; 09d3 82 ef
    705  09d5		       25 37		      CI	$37	; 09d5 25 37
    706  09d7		       92 eb		      BNC	maybeSpawn.reroll	; 09d7 92 eb
    707  09d9		       52		      LR	$2,A	; 09d9 52
    708  09da							; r0 = 0x55
    709  09da		       20 55		      LI	$55	; 09da 20 55
    710  09dc		       50		      LR	$0,A	; 09dc 50
    711  09dd							; use lower 2 bits of r6 as index to jump table
    712  09dd		       73		      LIS	%00000011	; 09dd 73
    713  09de		       f6		      NS	RNG.regLo	; 09de f6
    714  09df							; jump to (jump_table + 2*A)
    715  09df		       2a 09 e6 	      DCI	maybeSpawn.jumpTable	; 09df 2a 09 e6
    716  09e2		       8e		      ADC		; 09e2 8e
    717  09e3		       8e		      ADC		; 09e3 8e
    718  09e4		       0e		      LR	Q,DC	; 09e4 0e
    719  09e5		       0d		      LR	P0,Q	; 09e5 0d
    720  09e6							; Jump table !
    721  09e6				   maybeSpawn.jumpTable
    722  09e6		       90 07		      BR	maybeSpawn.label_1	; 09e6 90 07
    723  09e8		       90 0a		      BR	maybeSpawn.label_2	; 09e8 90 0a
    724  09ea		       90 13		      BR	maybeSpawn.label_3	; 09ea 90 13
    725  09ec		       90 1c		      BR	maybeSpawn.label_4	; 09ec 90 1c
    726  09ee
    727  09ee				   maybeSpawn.label_1
    728  09ee							; r2 = 0x11
    729  09ee		       20 11		      LI	$11	; 09ee 20 11
    730  09f0		       52		      LR	$2,A	; 09f0 52
    731  09f1		       90 1a		      BR	maybeSpawn.handlePlayers	; 09f1 90 1a
    732  09f3
    733  09f3				   maybeSpawn.label_2
    734  09f3							; r1 = -((0x30 & reg_a) >> 4) + 0xD8
    735  09f3		       20 30		      LI	$30	; 09f3 20 30
    736  09f5		       fa		      NS	$a	; 09f5 fa
    737  09f6		       14		      SR	4	; 09f6 14
    738  09f7		       18		      COM		; 09f7 18
    739  09f8		       1f		      INC		; 09f8 1f
    740  09f9		       24 d8		      AI	$d8	; 09f9 24 d8
    741  09fb		       51		      LR	$1,A	; 09fb 51
    742  09fc		       90 0f		      BR	maybeSpawn.handlePlayers	; 09fc 90 0f
    743  09fe
    744  09fe				   maybeSpawn.label_3
    745  09fe							; r2 = -((0x30 & reg_a) >> 4) + 0xB8
    746  09fe		       20 30		      LI	$30	; 09fe 20 30
    747  0a00		       fa		      NS	$a	; 0a00 fa
    748  0a01		       14		      SR	4	; 0a01 14
    749  0a02		       18		      COM		; 0a02 18
    750  0a03		       1f		      INC		; 0a03 1f
    751  0a04		       24 b8		      AI	$b8	; 0a04 24 b8
    752  0a06		       52		      LR	$2,A	; 0a06 52
    753  0a07		       90 04		      BR	maybeSpawn.handlePlayers	; 0a07 90 04
    754  0a09
    755  0a09				   maybeSpawn.label_4
    756  0a09							; r1 = 0x11
    757  0a09		       20 11		      LI	$11	; 0a09 20 11
    758  0a0b		       51		      LR	$1,A	; 0a0b 51
    759  0a0c
    760  0a0c				   maybeSpawn.handlePlayers
    761  0a0c							; if (reg_b > 1) skip ahead
    762  0a0c		       4b		      LR	A, main.curBall	; 0a0c 4b
    763  0a0d		       25 01		      CI	[MAX_PLAYERS-1]	; 0a0d 25 01
    764  0a0f		       92 0b		      BNC	maybeSpawn.exit	; 0a0f 92 0b
    765  0a11
    766  0a11							; ypos = 0x23
    767  0a11		       20 23		      LI	$23	; 0a11 20 23
    768  0a13		       52		      LR	$2,A	; 0a13 52
    769  0a14							; if (curBall != 0)
    770  0a14							;  xpos = 0x33
    771  0a14							; else xpos = 0x33 + 0x07
    772  0a14		       20 33		      LI	$33	; 0a14 20 33
    773  0a16		       94 03		      BNZ	maybeSpawn.setXPos	; 0a16 94 03
    774  0a18		       24 07		      AI	$07	; 0a18 24 07
    775  0a1a
    776  0a1a				   maybeSpawn.setXPos
    777  0a1a		       51		      LR	$1,A	; 0a1a 51
    778  0a1b
    779  0a1b				   maybeSpawn.exit
    780  0a1b							; Save xpos and ypos
    781  0a1b		       28 09 a2 	      PI	saveBall	; 0a1b 28 09 a2
    782  0a1e							; Exit
    783  0a1e		       09		      LR	P,K	; 0a1e 09
    784  0a1f		       1c		      POP		; 0a1f 1c
    785  0a20
    786  0a20
    787  0a20							; Update score
    788  0a20							; Args
    789  0a20		       00 00	   drawTimer.xpos =	0
    790  0a20		       00 02	   drawTimer.ypos =	2
    791  0a20							; ISAR should point to the lower byte of the score
    792  0a20							; Local Constants
    793  0a20		       00 0a	   drawTimer.yOffset =	$0A
    794  0a20		       00 fb	   drawTimer.xDelta =	<[-5]
    795  0a20		       00 0f	   drawTimer.digitMask =	$0F
    796  0a20
    797  0a20				   drawTimer
    798  0a20		       08		      LR	K,P	; 0a20 08
    799  0a21							; Update score display (ones)
    800  0a21							; Load x pos from r0 to r1
    801  0a21		       40		      LR	A, drawTimer.xpos	; 0a21 40
    802  0a22		       51		      LR	draw.xpos, A	; 0a22 51
    803  0a23							; y pos
    804  0a23		       20 0a		      LI	drawTimer.yOffset	; 0a23 20 0a
    805  0a25		       c2		      AS	drawTimer.ypos	; 0a25 c2
    806  0a26		       52		      LR	draw.ypos, A	; 0a26 52
    807  0a27							; Set glyph
    808  0a27		       20 0f		      LI	drawTimer.digitMask	; 0a27 20 0f
    809  0a29		       fc		      NS	(IS)	; 0a29 fc
    810  0a2a		       50		      LR	draw.glyph, A	; 0a2a 50
    811  0a2b							; Width
    812  0a2b		       74		      LIS	$4	; 0a2b 74
    813  0a2c		       54		      LR	draw.width, A	; 0a2c 54
    814  0a2d							; Height
    815  0a2d		       75		      LIS	$5	; 0a2d 75
    816  0a2e		       55		      LR	draw.height, A	; 0a2e 55
    817  0a2f		       28 08 58 	      PI	drawGlyph	; 0a2f 28 08 58
    818  0a32
    819  0a32							; Update score display (tens)
    820  0a32							; Set glyph
    821  0a32		       4e		      LR	A,(IS)-	; 0a32 4e
    822  0a33		       14		      SR	4	; 0a33 14
    823  0a34		       50		      LR	draw.glyph, A	; 0a34 50
    824  0a35							; Subtract 5 from x pos
    825  0a35		       20 fb		      LI	drawTimer.xDelta	; 0a35 20 fb
    826  0a37		       c1		      AS	draw.xpos	; 0a37 c1
    827  0a38		       51		      LR	draw.xpos, A	; 0a38 51
    828  0a39		       28 08 58 	      PI	drawGlyph	; 0a39 28 08 58
    829  0a3c
    830  0a3c							; Update score display (hundreds)
    831  0a3c							; Set glyph
    832  0a3c		       4c		      LR	A,(IS)	; 0a3c 4c
    833  0a3d		       21 0f		      NI	drawTimer.digitMask	; 0a3d 21 0f
    834  0a3f		       50		      LR	draw.glyph, A	; 0a3f 50
    835  0a40							; Subtract 5 from x pos
    836  0a40		       20 fb		      LI	drawTimer.xDelta	; 0a40 20 fb
    837  0a42		       c1		      AS	draw.xpos	; 0a42 c1
    838  0a43		       51		      LR	draw.xpos, A	; 0a43 51
    839  0a44		       28 08 58 	      PI	drawGlyph	; 0a44 28 08 58
    840  0a47
    841  0a47							; Update score display (thousands)
    842  0a47							; Load glyph
    843  0a47		       4c		      LR	A,(IS)	; 0a47 4c
    844  0a48		       14		      SR	4	; 0a48 14
    845  0a49		       50		      LR	draw.glyph, A	; 0a49 50
    846  0a4a							; Subtract 5 from x pos
    847  0a4a		       20 fb		      LI	drawTimer.xDelta	; 0a4a 20 fb
    848  0a4c		       c1		      AS	draw.xpos	; 0a4c c1
    849  0a4d		       51		      LR	draw.xpos, A	; 0a4d 51
    850  0a4e		       28 08 58 	      PI	drawGlyph	; 0a4e 28 08 58
    851  0a51							; Exit
    852  0a51		       09		      LR	P,K	; 0a51 09
    853  0a52		       1c		      POP		; 0a52 1c
    854  0a53
    855  0a53							; Do thing
    856  0a53							; Args
    857  0a53							; 070 = ball sizes
    858  0a53							; velocity = r3
    859  0a53
    860  0a53							; reg_b (r11 or o13) - Index of thing to finangle
    861  0a53				   handleBall
    862  0a53		       08		      LR	K,P	; 0a53 08
    863  0a54							; load x pos of thing
    864  0a54		       20 10		      LI	balls.xpos	; 0a54 20 10
    865  0a56		       cb		      AS	main.curBall	; 0a56 cb
    866  0a57		       0b		      LR	IS,A	; 0a57 0b
    867  0a58		       4c		      LR	A,(IS)	; 0a58 4c
    868  0a59		       51		      LR	draw.xpos, A	; 0a59 51
    869  0a5a							; load y pos of thing from $1b + index
    870  0a5a		       0a		      LR	A,IS	; 0a5a 0a
    871  0a5b		       24 0b		      AI	balls.arraySize	; 0a5b 24 0b
    872  0a5d		       0b		      LR	IS,A	; 0a5d 0b
    873  0a5e		       4c		      LR	A,(IS)	; 0a5e 4c
    874  0a5f		       59		      LR	$9,A	; 0a5f 59
    875  0a60		       21 3f		      NI	$3f	; 0a60 21 3f
    876  0a62		       52		      LR	draw.ypos, A	; 0a62 52
    877  0a63							; Load size of thing from o70
    878  0a63		       67		      LISU	7	; 0a63 67
    879  0a64		       68		      LISL	0	; 0a64 68
    880  0a65		       4c		      LR	A,(IS)	; 0a65 4c
    881  0a66		       54		      LR	draw.width, A	; 0a66 54
    882  0a67		       55		      LR	draw.height, A	; 0a67 55
    883  0a68							; Color?
    884  0a68		       20 80		      LI	draw.drawRect	; 0a68 20 80
    885  0a6a		       50		      LR	draw.glyph, A	; 0a6a 50
    886  0a6b							; Undraw player
    887  0a6b		       28 08 62 	      PI	drawBox	; 0a6b 28 08 62
    888  0a6e
    889  0a6e							; reload ypos
    890  0a6e		       49		      LR	A,$9	; 0a6e 49
    891  0a6f		       52		      LR	draw.ypos, A	; 0a6f 52
    892  0a70
    893  0a70							; get bitpacked velocity ?
    894  0a70							; ISAR = o46 + index/2
    895  0a70		       4b		      LR	A, main.curBall	; 0a70 4b
    896  0a71		       12		      SR	1	; 0a71 12
    897  0a72		       24 26		      AI	balls.velocity	; 0a72 24 26
    898  0a74		       0b		      LR	IS,A	; 0a74 0b
    899  0a75
    900  0a75							; if (index is odd)
    901  0a75							;  r6 = $0F
    902  0a75							; else
    903  0a75							;  r6 = $F0
    904  0a75		       71		      LIS	$1	; 0a75 71
    905  0a76		       fb		      NS	main.curBall	; 0a76 fb
    906  0a77		       7f		      LIS	$f	; 0a77 7f
    907  0a78		       94 02		      BNZ	A0a7b	; 0a78 94 02
    908  0a7a		       18		      COM		; 0a7a 18
    909  0a7b				   A0a7b
    910  0a7b		       56		      LR	$6,A	; 0a7b 56
    911  0a7c							; store one nybble in r0
    912  0a7c		       18		      COM		; 0a7c 18
    913  0a7d		       fc		      NS	(IS)	; 0a7d fc
    914  0a7e		       50		      LR	$0,A	; 0a7e 50
    915  0a7f							; store the other nybble in r3
    916  0a7f		       46		      LR	A,$6	; 0a7f 46
    917  0a80		       fc		      NS	(IS)	; 0a80 fc
    918  0a81		       53		      LR	$3,A	; 0a81 53
    919  0a82							; if the desired nybble is the upper nybble
    920  0a82							; shift it right 4 and then store in r3
    921  0a82		       14		      SR	4	; 0a82 14
    922  0a83		       84 02		      BZ	A0a86	; 0a83 84 02
    923  0a85		       53		      LR	$3,A	; 0a85 53
    924  0a86				   A0a86
    925  0a86							; if(xpos > 0)
    926  0a86							;  xpos += xvel
    927  0a86							; else
    928  0a86							;  xpos -= xvel
    929  0a86		       70		      LIS	$0	; 0a86 70
    930  0a87		       c1		      AS	draw.xpos	; 0a87 c1
    931  0a88		       1e		      LR	J,W	; 0a88 1e
    932  0a89							; a = r3/4
    933  0a89		       43		      LR	A,$3	; 0a89 43
    934  0a8a		       12		      SR	1	; 0a8a 12
    935  0a8b		       12		      SR	1	; 0a8b 12
    936  0a8c		       1d		      LR	W,J	; 0a8c 1d
    937  0a8d							; if r1 was positive, branch ahead
    938  0a8d		       81 03		      BP	A0a91	; 0a8d 81 03
    939  0a8f							; else, take the 2's complement
    940  0a8f		       18		      COM		; 0a8f 18
    941  0a90		       1f		      INC		; 0a90 1f
    942  0a91				   A0a91		; r1 = r1 + a
    943  0a91		       c1		      AS	$1	; 0a91 c1
    944  0a92		       51		      LR	$1,A	; 0a92 51
    945  0a93
    946  0a93							; if(ypos > 0)
    947  0a93							;  ypos += yvel
    948  0a93							; else
    949  0a93							;  ypos -= yvel
    950  0a93		       70		      LIS	$0	; 0a93 70
    951  0a94		       c2		      AS	draw.ypos	; 0a94 c2
    952  0a95		       1e		      LR	J,W	; 0a95 1e
    953  0a96		       73		      LIS	$3	; 0a96 73
    954  0a97		       f3		      NS	$3	; 0a97 f3
    955  0a98		       1d		      LR	W,J	; 0a98 1d
    956  0a99		       81 03		      BP	A0a9d	; 0a99 81 03
    957  0a9b		       18		      COM		; 0a9b 18
    958  0a9c		       1f		      INC		; 0a9c 1f
    959  0a9d				   A0a9d
    960  0a9d		       c2		      AS	$2	; 0a9d c2
    961  0a9e		       52		      LR	$2,A	; 0a9e 52
    962  0a9f							; Ball/Wall collision detection
    963  0a9f							; if (reg_b <= 1)
    964  0a9f							;  r4 = o61
    965  0a9f							; else
    966  0a9f							;  r4 = o60
      0  0a9f					      SETISAR	bounds.rightEnemy	; 0a9f 66 68
      1  0a9f		       66		      lisu	[[bounds.rightEnemy] >> 3]
      2  0aa0		       68		      lisl	[[bounds.rightEnemy] & %111]
    968  0aa1		       4b		      LR	A, main.curBall	; 0aa1 4b
    969  0aa2		       25 01		      CI	[MAX_PLAYERS-1]	; 0aa2 25 01
    970  0aa4		       92 02		      BNC	A0aa7	; 0aa4 92 02
      0  0aa6					      SETISARL	bounds.rightPlayer	; 0aa6 69
      1  0aa6		       69		      lisl	[[bounds.rightPlayer] & %111]
    972  0aa7
    973  0aa7				   A0aa7
    974  0aa7		       4c		      LR	A,(IS)	; 0aa7 4c
    975  0aa8		       54		      LR	$4,A	; 0aa8 54
    976  0aa9							; r5 = (previous isar reg + 3)
    977  0aa9		       0a		      LR	A,IS	; 0aa9 0a
    978  0aaa		       24 03		      AI	$03	; 0aaa 24 03
    979  0aac		       0b		      LR	IS,A	; 0aac 0b
    980  0aad		       4c		      LR	A,(IS)	; 0aad 4c
    981  0aae		       55		      LR	$5,A	; 0aae 55
    982  0aaf							; Clear r0
    983  0aaf		       70		      LIS	$0	; 0aaf 70
    984  0ab0		       50		      LR	$0,A	; 0ab0 50
    985  0ab1							; if r1 is positive, branch ahead
    986  0ab1		       c1		      AS	$1	; 0ab1 c1
    987  0ab2		       91 18		      BM	A0acb	; 0ab2 91 18
    988  0ab4		       c4		      AS	$4	; 0ab4 c4
    989  0ab5		       92 29		      BNC	A0adf	; 0ab5 92 29
    990  0ab7
    991  0ab7		       44		      LR	A,$4	; 0ab7 44
    992  0ab8		       18		      COM		; 0ab8 18
    993  0ab9		       1f		      INC		; 0ab9 1f
    994  0aba		       24 80		      AI	$80	; 0aba 24 80
    995  0abc		       51		      LR	$1,A	; 0abc 51
    996  0abd		       20 40		      LI	$40	; 0abd 20 40
    997  0abf		       53		      LR	$3,A	; 0abf 53
    998  0ac0		       28 0c c8 	      PI	playSound	; 0ac0 28 0c c8
    999  0ac3
   1000  0ac3		       67	   A0ac3      LISU	7	; 0ac3 67
   1001  0ac4		       69		      LISL	1	; 0ac4 69
   1002  0ac5		       4c		      LR	A,(IS)	; 0ac5 4c
   1003  0ac6		       13		      SL	1	; 0ac6 13
   1004  0ac7		       13		      SL	1	; 0ac7 13
   1005  0ac8		       50		      LR	$0,A	; 0ac8 50
   1006  0ac9		       90 15		      BR	A0adf	; 0ac9 90 15
   1007  0acb
   1008  0acb		       41	   A0acb      LR	A,$1	; 0acb 41
   1009  0acc		       21 7f		      NI	$7f	; 0acc 21 7f
   1010  0ace		       18		      COM		; 0ace 18
   1011  0acf		       1f		      INC		; 0acf 1f
      0  0ad0					      SETISAR	bounds.left	; 0ad0 66 6a
      1  0ad0		       66		      lisu	[[bounds.left] >> 3]
      2  0ad1		       6a		      lisl	[[bounds.left] & %111]
   1013  0ad2		       cc		      AS	(IS)	; 0ad2 cc
   1014  0ad3		       92 0b		      BNC	A0adf	; 0ad3 92 0b
   1015  0ad5
   1016  0ad5		       4c		      LR	A,(IS)	; 0ad5 4c
   1017  0ad6		       51		      LR	$1,A	; 0ad6 51  ; draw.xpos ?
   1018  0ad7		       20 40		      LI	$40	; 0ad7 20 40
   1019  0ad9		       53		      LR	$3,A	; 0ad9 53
   1020  0ada		       28 0c c8 	      PI	playSound	; 0ada 28 0c c8
   1021  0add		       90 e5		      BR	A0ac3	; 0add 90 e5
   1022  0adf
   1023  0adf		       70	   A0adf      LIS	$0	; 0adf 70
   1024  0ae0		       c2		      AS	$2	; 0ae0 c2
   1025  0ae1		       91 19		      BM	A0afb	; 0ae1 91 19
   1026  0ae3		       21 3f		      NI	$3f	; 0ae3 21 3f
   1027  0ae5		       c5		      AS	$5	; 0ae5 c5
   1028  0ae6		       92 27		      BNC	A0b0e	; 0ae6 92 27
   1029  0ae8
   1030  0ae8		       45		      LR	A,$5	; 0ae8 45
   1031  0ae9		       18		      COM		; 0ae9 18
   1032  0aea		       1f		      INC		; 0aea 1f
   1033  0aeb		       24 80		      AI	$80	; 0aeb 24 80
   1034  0aed		       52		      LR	$2,A	; 0aed 52
   1035  0aee		       20 40		      LI	$40	; 0aee 20 40
   1036  0af0		       53		      LR	$3,A	; 0af0 53
   1037  0af1		       28 0c c8 	      PI	playSound	; 0af1 28 0c c8
   1038  0af4
   1039  0af4		       67	   A0af4      LISU	7	; 0af4 67
   1040  0af5		       69		      LISL	1	; 0af5 69
   1041  0af6		       4c		      LR	A,(IS)	; 0af6 4c
   1042  0af7		       c0		      AS	$0	; 0af7 c0
   1043  0af8		       50		      LR	$0,A	; 0af8 50
   1044  0af9		       90 14		      BR	A0b0e	; 0af9 90 14
   1045  0afb
   1046  0afb		       66	   A0afb      LISU	6	; 0afb 66
   1047  0afc		       21 3f		      NI	$3f	; 0afc 21 3f
   1048  0afe		       18		      COM		; 0afe 18
   1049  0aff		       1f		      INC		; 0aff 1f
   1050  0b00		       6d		      LISL	5	; 0b00 6d
   1051  0b01		       cc		      AS	(IS)	; 0b01 cc
   1052  0b02		       92 0b		      BNC	A0b0e	; 0b02 92 0b
   1053  0b04
   1054  0b04		       4c		      LR	A,(IS)	; 0b04 4c
   1055  0b05		       52		      LR	$2,A	; 0b05 52
   1056  0b06		       20 40		      LI	$40	; 0b06 20 40
   1057  0b08		       53		      LR	$3,A	; 0b08 53
   1058  0b09		       28 0c c8 	      PI	playSound	; 0b09 28 0c c8
   1059  0b0c		       90 e7		      BR	A0af4	; 0b0c 90 e7
   1060  0b0e							; ?--
   1061  0b0e		       40	   A0b0e      LR	A,$0	; 0b0e 40
   1062  0b0f		       15		      SL	4	; 0b0f 15
   1063  0b10		       c0		      AS	$0	; 0b10 c0
   1064  0b11		       50		      LR	$0,A	; 0b11 50
   1065  0b12		       4b		      LR	A,$b	; 0b12 4b
   1066  0b13		       12		      SR	1	; 0b13 12
   1067  0b14		       24 26		      AI	$26	; 0b14 24 26
   1068  0b16		       0b		      LR	IS,A	; 0b16 0b
   1069  0b17		       71		      LIS	$1	; 0b17 71
   1070  0b18		       fb		      NS	$b	; 0b18 fb
   1071  0b19		       7f		      LIS	$f	; 0b19 7f
   1072  0b1a		       94 02		      BNZ	A0b1d	; 0b1a 94 02
   1073  0b1c
   1074  0b1c		       18		      COM		; 0b1c 18
   1075  0b1d		       57	   A0b1d      LR	$7,A	; 0b1d 57
   1076  0b1e		       18		      COM		; 0b1e 18
   1077  0b1f		       56		      LR	$6,A	; 0b1f 56
   1078  0b20		       fc		      NS	(IS)	; 0b20 fc
   1079  0b21		       54		      LR	$4,A	; 0b21 54
   1080  0b22		       47		      LR	A,$7	; 0b22 47
   1081  0b23		       fc		      NS	(IS)	; 0b23 fc
   1082  0b24		       55		      LR	$5,A	; 0b24 55
   1083  0b25		       20 33		      LI	$33	; 0b25 20 33
   1084  0b27		       f0		      NS	$0	; 0b27 f0
   1085  0b28		       84 0c		      BZ	A0b35	; 0b28 84 0c
   1086  0b2a
   1087  0b2a		       20 cc		      LI	$cc	; 0b2a 20 cc
   1088  0b2c		       f7		      NS	$7	; 0b2c f7
   1089  0b2d		       f5		      NS	$5	; 0b2d f5
   1090  0b2e		       55		      LR	$5,A	; 0b2e 55
   1091  0b2f		       20 33		      LI	$33	; 0b2f 20 33
   1092  0b31		       f0		      NS	$0	; 0b31 f0
   1093  0b32		       c5		      AS	$5	; 0b32 c5
   1094  0b33		       f7		      NS	$7	; 0b33 f7
   1095  0b34		       55		      LR	$5,A	; 0b34 55
   1096  0b35		       20 cc	   A0b35      LI	$cc	; 0b35 20 cc
   1097  0b37		       f0		      NS	$0	; 0b37 f0
   1098  0b38		       84 0c		      BZ	A0b45	; 0b38 84 0c
   1099  0b3a
   1100  0b3a		       20 33		      LI	$33	; 0b3a 20 33
   1101  0b3c		       f7		      NS	$7	; 0b3c f7
   1102  0b3d		       f5		      NS	$5	; 0b3d f5
   1103  0b3e		       55		      LR	$5,A	; 0b3e 55
   1104  0b3f		       20 cc		      LI	$cc	; 0b3f 20 cc
   1105  0b41		       f0		      NS	$0	; 0b41 f0
   1106  0b42		       c5		      AS	$5	; 0b42 c5
   1107  0b43		       f7		      NS	$7	; 0b43 f7
   1108  0b44		       55		      LR	$5,A	; 0b44 55
   1109  0b45		       45	   A0b45      LR	A,$5	; 0b45 45
   1110  0b46		       c4		      AS	$4	; 0b46 c4
   1111  0b47		       50		      LR	$0,A	; 0b47 50
   1112  0b48		       28 09 a2 	      PI	saveBall	; 0b48 28 09 a2
   1113  0b4b
   1114  0b4b		       2a 08 50 	      DCI	ballColors	; 0b4b 2a 08 50
   1115  0b4e		       4b		      LR	A,$b	; 0b4e 4b
   1116  0b4f		       25 01		      CI	[MAX_PLAYERS-1]	; 0b4f 25 01
   1117  0b51		       72		      LIS	$2	; 0b51 72
   1118  0b52		       92 02		      BNC	A0b55	; 0b52 92 02
   1119  0b54
   1120  0b54		       4b		      LR	A,$b	; 0b54 4b
   1121  0b55		       8e	   A0b55      ADC		; 0b55 8e
   1122  0b56		       42		      LR	A, draw.ypos	; 0b56 42
   1123  0b57		       21 7f		      NI	$7f	; 0b57 21 7f ; Should be $3F ?
   1124  0b59		       8b		      OM		; 0b59 8b
   1125  0b5a		       52		      LR	draw.ypos, A	; 0b5a 52
   1126  0b5b		       20 80		      LI	draw.drawRect	; 0b5b 20 80
   1127  0b5d		       50		      LR	draw.glyph, A	; 0b5d 50
   1128  0b5e		       67		      LISU	7	; 0b5e 67
   1129  0b5f		       68		      LISL	0	; 0b5f 68
   1130  0b60		       4c		      LR	A,(IS)	; 0b60 4c
   1131  0b61		       54		      LR	draw.width, A	; 0b61 54
   1132  0b62		       55		      LR	draw.height, A	; 0b62 55
   1133  0b63		       67		      LISU	7	; 0b63 67
   1134  0b64		       6a		      LISL	2	; 0b64 6a
   1135  0b65		       70		      LIS	$0	; 0b65 70
   1136  0b66		       cc		      AS	(IS)	; 0b66 cc
   1137  0b67		       91 04		      BM	A0b6c	; 0b67 91 04
   1138  0b69
   1139  0b69							; Redraw thing
   1140  0b69		       28 08 62 	      PI	drawBox	; 0b69 28 08 62
   1141  0b6c							; Return
   1142  0b6c		       09	   A0b6c      LR	P,K	; 0b6c 09
   1143  0b6d		       1c		      POP		; 0b6d 1c
   1144  0b6e
   1145  0b6e							; Collision detection ?
   1146  0b6e							; Args
   1147  0b6e							;  r11 - Current ball ?
   1148  0b6e							;
   1149  0b6e							; Clobbers
   1150  0b6e							; 071 - Used as a loop counter
   1151  0b6e		       08	   ballCollision LR	K,P	; 0b6e 08
   1152  0b6f							; setting up the collision loop counter
   1153  0b6f							; 071 = (num_balls(??) & 0x0F) + 1
   1154  0b6f		       65		      LISU	5	; 0b6f 65
   1155  0b70		       6f		      LISL	7	; 0b70 6f
   1156  0b71		       20 0f		      LI	$0f	; 0b71 20 0f
   1157  0b73		       fc		      NS	(IS)	; 0b73 fc
   1158  0b74		       67		      LISU	7	; 0b74 67
   1159  0b75		       69		      LISL	1	; 0b75 69
   1160  0b76		       1f		      INC		; 0b76 1f
   1161  0b77		       5c		      LR	(IS),A	; 0b77 5c
   1162  0b78							; loop_counter--
   1163  0b78		       67	   A0b78      LISU	7	; 0b78 67
   1164  0b79		       69		      LISL	1	; 0b79 69
   1165  0b7a		       3c		      DS	(IS)	; 0b7a 3c
   1166  0b7b							; if(loop_counter == 0), return
   1167  0b7b		       91 f0		      BM	A0b6c	; 0b7b 91 f0
   1168  0b7d							; if(loop_counter == current_ball), return
   1169  0b7d		       4c		      LR	A,(IS)	; 0b7d 4c
   1170  0b7e		       eb		      XS	$b	; 0b7e eb
   1171  0b7f		       84 f8		      BZ	A0b78	; 0b7f 84 f8
   1172  0b81
   1173  0b81							; Check if we're in 2-player mode
   1174  0b81		       6d		      LISL	5	; 0b81 6d
   1175  0b82		       71		      LIS	$1	; 0b82 71
   1176  0b83		       fc		      NS	(IS)	; 0b83 fc
   1177  0b84							; If so, skip ahead
   1178  0b84		       94 07		      BNZ	A0b8c	; 0b84 94 07
   1179  0b86							; If not, check if the current ball is player 2
   1180  0b86		       69		      LISL	1	; 0b86 69
   1181  0b87		       4c		      LR	A,(IS)	; 0b87 4c
   1182  0b88		       25 01		      CI	$01	; 0b88 25 01
   1183  0b8a							; If so, skip the current ball
   1184  0b8a		       84 ed		      BZ	A0b78	; 0b8a 84 ed
   1185  0b8c							; r1 = xpos[current_ball]
   1186  0b8c		       20 10	   A0b8c      LI	$10	; 0b8c 20 10
   1187  0b8e		       cb		      AS	$b	; 0b8e cb
   1188  0b8f		       0b		      LR	IS,A	; 0b8f 0b
   1189  0b90		       4c		      LR	A,(IS)	; 0b90 4c
   1190  0b91		       21 7f		      NI	$7f	; 0b91 21 7f
   1191  0b93		       51		      LR	$1,A	; 0b93 51
   1192  0b94							; r2 = ypos[current_ball]
   1193  0b94		       0a		      LR	A,IS	; 0b94 0a
   1194  0b95		       24 0b		      AI	$0b	; 0b95 24 0b
   1195  0b97		       0b		      LR	IS,A	; 0b97 0b
   1196  0b98		       4c		      LR	A,(IS)	; 0b98 4c
   1197  0b99		       21 3f		      NI	$3f	; 0b99 21 3f
   1198  0b9b		       52		      LR	$2,A	; 0b9b 52
   1199  0b9c							; do some sort of check with xpos[loop_counter]
   1200  0b9c		       67		      LISU	7	; 0b9c 67
   1201  0b9d		       69		      LISL	1	; 0b9d 69
   1202  0b9e		       20 10		      LI	$10	; 0b9e 20 10
   1203  0ba0		       cc		      AS	(IS)	; 0ba0 cc
   1204  0ba1		       0b		      LR	IS,A	; 0ba1 0b
   1205  0ba2		       4c		      LR	A,(IS)	; 0ba2 4c
   1206  0ba3		       21 7f		      NI	$7f	; 0ba3 21 7f
   1207  0ba5		       18		      COM		; 0ba5 18
   1208  0ba6		       1f		      INC		; 0ba6 1f
   1209  0ba7		       c1		      AS	$1	; 0ba7 c1
   1210  0ba8		       1e		      LR	J,W	; 0ba8 1e
   1211  0ba9		       81 03		      BP	A0bad	; 0ba9 81 03
   1212  0bab
   1213  0bab		       18		      COM		; 0bab 18
   1214  0bac		       1f		      INC		; 0bac 1f
   1215  0bad		       51	   A0bad      LR	$1,A	; 0bad 51
   1216  0bae		       0a		      LR	A,IS	; 0bae 0a
   1217  0baf							; Check if workin on a player ball ?
   1218  0baf		       25 11		      CI	$11	; 0baf 25 11
   1219  0bb1		       92 0b		      BNC	A0bbd	; 0bb1 92 0b
   1220  0bb3
   1221  0bb3		       1d		      LR	W,J	; 0bb3 1d
   1222  0bb4		       91 08		      BM	A0bbd	; 0bb4 91 08
   1223  0bb6
   1224  0bb6		       20 c0		      LI	$c0	; 0bb6 20 c0
   1225  0bb8		       fa		      NS	$a	; 0bb8 fa
   1226  0bb9		       12		      SR	1	; 0bb9 12
   1227  0bba		       12		      SR	1	; 0bba 12
   1228  0bbb		       90 04		      BR	A0bc0	; 0bbb 90 04
   1229  0bbd
   1230  0bbd		       20 30	   A0bbd      LI	$30	; 0bbd 20 30
   1231  0bbf		       fa		      NS	$a	; 0bbf fa
   1232  0bc0		       14	   A0bc0      SR	4	; 0bc0 14
   1233  0bc1		       18		      COM		; 0bc1 18
   1234  0bc2		       1f		      INC		; 0bc2 1f
   1235  0bc3		       c1		      AS	$1	; 0bc3 c1
   1236  0bc4							; If so, restart loop
   1237  0bc4		       81 b3		      BP	A0b78	; 0bc4 81 b3
   1238  0bc6							; do check with ypos[loop_counter] ??
   1239  0bc6		       0a		      LR	A,IS	; 0bc6 0a
   1240  0bc7		       24 0b		      AI	$0b	; 0bc7 24 0b
   1241  0bc9		       0b		      LR	IS,A	; 0bc9 0b
   1242  0bca		       4c		      LR	A,(IS)	; 0bca 4c
   1243  0bcb		       21 3f		      NI	$3f	; 0bcb 21 3f
   1244  0bcd		       18		      COM		; 0bcd 18
   1245  0bce		       1f		      INC		; 0bce 1f
   1246  0bcf		       c2		      AS	$2	; 0bcf c2
   1247  0bd0		       1e		      LR	J,W	; 0bd0 1e
   1248  0bd1		       81 03		      BP	A0bd5	; 0bd1 81 03
   1249  0bd3
   1250  0bd3		       18		      COM		; 0bd3 18
   1251  0bd4		       1f		      INC		; 0bd4 1f
   1252  0bd5		       52	   A0bd5      LR	$2,A	; 0bd5 52
   1253  0bd6		       0a		      LR	A,IS	; 0bd6 0a
   1254  0bd7		       25 1c		      CI	$1c	; 0bd7 25 1c
   1255  0bd9		       92 0b		      BNC	A0be5	; 0bd9 92 0b
   1256  0bdb
   1257  0bdb		       1d		      LR	W,J	; 0bdb 1d
   1258  0bdc		       91 08		      BM	A0be5	; 0bdc 91 08
   1259  0bde		       20 c0		      LI	$c0	; 0bde 20 c0
   1260  0be0		       fa		      NS	$a	; 0be0 fa
   1261  0be1		       12		      SR	1	; 0be1 12
   1262  0be2		       12		      SR	1	; 0be2 12
   1263  0be3		       90 04		      BR	A0be8	; 0be3 90 04
   1264  0be5
   1265  0be5		       20 30	   A0be5      LI	$30	; 0be5 20 30
   1266  0be7		       fa		      NS	$a	; 0be7 fa
   1267  0be8		       14	   A0be8      SR	4	; 0be8 14
   1268  0be9		       18		      COM		; 0be9 18
   1269  0bea		       1f		      INC		; 0bea 1f
   1270  0beb		       c2		      AS	$2	; 0beb c2
   1271  0bec							; If so, restart loop
   1272  0bec		       81 8b		      BP	A0b78	; 0bec 81 8b
   1273  0bee
   1274  0bee							; Check if the collision was with a player
   1275  0bee							;  If so, game over
   1276  0bee							;  Else, skip ahead
   1277  0bee		       67		      LISU	7	; 0bee 67
   1278  0bef		       69		      LISL	1	; 0bef 69
   1279  0bf0		       4c		      LR	A,(IS)	; 0bf0 4c
   1280  0bf1		       25 01		      CI	$01	; 0bf1 25 01
   1281  0bf3		       92 04		      BNC	A0bf8	; 0bf3 92 04
   1282  0bf5							; Game over
   1283  0bf5		       29 0e 44 	      JMP	gameOver	; 0bf5 29 0e 44
   1284  0bf8
   1285  0bf8		       20 80	   A0bf8      LI	$80	; 0bf8 20 80
   1286  0bfa		       53		      LR	$3,A	; 0bfa 53
   1287  0bfb		       28 0c c8 	      PI	playSound	; 0bfb 28 0c c8
   1288  0bfe		       28 08 c1 	      PI	roll_RNG	; 0bfe 28 08 c1
   1289  0c01
   1290  0c01		       42		      LR	A,$2	; 0c01 42
   1291  0c02		       25 01		      CI	$01	; 0c02 25 01
   1292  0c04		       82 3c		      BC	A0c41	; 0c04 82 3c
   1293  0c06
   1294  0c06		       20 10		      LI	$10	; 0c06 20 10
   1295  0c08		       cb		      AS	$b	; 0c08 cb
   1296  0c09		       0b		      LR	IS,A	; 0c09 0b
   1297  0c0a		       20 80		      LI	$80	; 0c0a 20 80
   1298  0c0c		       f6		      NS	$6	; 0c0c f6
   1299  0c0d		       ec		      XS	(IS)	; 0c0d ec
   1300  0c0e		       5c		      LR	(IS),A	; 0c0e 5c
   1301  0c0f		       1e		      LR	J,W	; 0c0f 1e
   1302  0c10		       67		      LISU	7	; 0c10 67
   1303  0c11		       69		      LISL	1	; 0c11 69
   1304  0c12		       20 10		      LI	$10	; 0c12 20 10
   1305  0c14		       cc		      AS	(IS)	; 0c14 cc
   1306  0c15		       0b		      LR	IS,A	; 0c15 0b
   1307  0c16		       20 80		      LI	$80	; 0c16 20 80
   1308  0c18		       f7		      NS	$7	; 0c18 f7
   1309  0c19		       cc		      AS	(IS)	; 0c19 cc
   1310  0c1a		       5c		      LR	(IS),A	; 0c1a 5c
   1311  0c1b		       20 44		      LI	$44	; 0c1b 20 44
   1312  0c1d		       58		      LR	$8,A	; 0c1d 58
   1313  0c1e		       4b		      LR	A,$b	; 0c1e 4b
   1314  0c1f		       50		      LR	$0,A	; 0c1f 50
   1315  0c20
   1316  0c20				   A0c20
      0  0c20					      SETISAR	gameMode
      1  0c20		       67		      lisu	[[gameMode] >> 3]
      2  0c21		       6d		      lisl	[[gameMode] & %111]
   1318  0c22							;	LISU 7 		  ; 0c20 67
   1319  0c22							;		 LISL 5 		  ; 0c21 6d
   1320  0c22		       70		      LIS	$0	; 0c22 70
   1321  0c23		       cc		      AS	(IS)	; 0c23 cc
   1322  0c24		       81 04		      BP	A0c29	; 0c24 81 04
   1323  0c26							; If so, restart loop
   1324  0c26		       29 0b 78 	      JMP	A0b78	; 0c26 29 0b 78
   1325  0c29
   1326  0c29		       40	   A0c29      LR	A,$0	; 0c29 40
   1327  0c2a		       12		      SR	1	; 0c2a 12
   1328  0c2b		       24 26		      AI	$26	; 0c2b 24 26
   1329  0c2d		       0b		      LR	IS,A	; 0c2d 0b
   1330  0c2e		       71		      LIS	$1	; 0c2e 71
   1331  0c2f		       f0		      NS	$0	; 0c2f f0
   1332  0c30		       7f		      LIS	$f	; 0c30 7f
   1333  0c31		       94 02		      BNZ	A0c34	; 0c31 94 02
   1334  0c33
   1335  0c33		       18		      COM		; 0c33 18
   1336  0c34		       53	   A0c34      LR	$3,A	; 0c34 53
   1337  0c35		       18		      COM		; 0c35 18
   1338  0c36		       fc		      NS	(IS)	; 0c36 fc
   1339  0c37		       54		      LR	$4,A	; 0c37 54
   1340  0c38		       43		      LR	A,$3	; 0c38 43
   1341  0c39		       fc		      NS	(IS)	; 0c39 fc
   1342  0c3a		       c8		      AS	$8	; 0c3a c8
   1343  0c3b		       f3		      NS	$3	; 0c3b f3
   1344  0c3c		       c4		      AS	$4	; 0c3c c4
   1345  0c3d		       5c		      LR	(IS),A	; 0c3d 5c
   1346  0c3e							; Exit
   1347  0c3e		       29 0b 6c 	      JMP	A0b6c	; 0c3e 29 0b 6c
   1348  0c41
   1349  0c41		       67	   A0c41      LISU	7	; 0c41 67
   1350  0c42		       69		      LISL	1	; 0c42 69
   1351  0c43		       4c		      LR	A,(IS)	; 0c43 4c
   1352  0c44		       50		      LR	$0,A	; 0c44 50
   1353  0c45		       24 1b		      AI	$1b	; 0c45 24 1b
   1354  0c47		       0b		      LR	IS,A	; 0c47 0b
   1355  0c48		       20 80		      LI	$80	; 0c48 20 80
   1356  0c4a		       ec		      XS	(IS)	; 0c4a ec
   1357  0c4b		       5c		      LR	(IS),A	; 0c4b 5c
   1358  0c4c		       1e		      LR	J,W	; 0c4c 1e
   1359  0c4d		       20 1b		      LI	$1b	; 0c4d 20 1b
   1360  0c4f		       cb		      AS	$b	; 0c4f cb
   1361  0c50		       0b		      LR	IS,A	; 0c50 0b
   1362  0c51		       4c		      LR	A,(IS)	; 0c51 4c
   1363  0c52		       22 80		      OI	$80	; 0c52 22 80
   1364  0c54		       1d		      LR	W,J	; 0c54 1d
   1365  0c55		       81 03		      BP	A0c59	; 0c55 81 03
   1366  0c57
   1367  0c57		       21 3f		      NI	$3f	; 0c57 21 3f
   1368  0c59		       5c	   A0c59      LR	(IS),A	; 0c59 5c
   1369  0c5a		       20 44		      LI	$44	; 0c5a 20 44
   1370  0c5c		       58		      LR	$8,A	; 0c5c 58
   1371  0c5d		       90 c2		      BR	A0c20	; 0c5d 90 c2
   1372  0c5f							; End collision routine
   1373  0c5f
   1374  0c5f							; Set playfield bounds?
   1375  0c5f							; Args
   1376  0c5f							;  r1 - ??
   1377  0c5f							;  r2 -
   1378  0c5f							;  r4 -
   1379  0c5f							;  r10 - ??
   1380  0c5f							; Clobbers
   1381  0c5f							;  r6 - via RNG call
   1382  0c5f							;  r7 - via RNG call
   1383  0c5f							;  ISAR[x] to ISAR[x+2]
   1384  0c5f		       08	   A0c5f      LR	K,P	; 0c5f 08
   1385  0c60							; Reroll RNG until r6 is non-zero
   1386  0c60		       28 08 c1    A0c60      PI	roll_RNG	; 0c60 28 08 c1
   1387  0c63		       70		      LIS	$0	; 0c63 70
   1388  0c64		       c6		      AS	$6	; 0c64 c6
   1389  0c65		       84 fa		      BZ	A0c60	; 0c65 84 fa
   1390  0c67							; if(r1 == 0x58)
   1391  0c67							;  if(r6 < 0x0B)
   1392  0c67							;   go back and reroll
   1393  0c67							; else if(r6 < 0x12)
   1394  0c67							;   go back and reroll
   1395  0c67		       41		      LR	A,$1	; 0c67 41
   1396  0c68		       25 58		      CI	$58	; 0c68 25 58
   1397  0c6a		       46		      LR	A,$6	; 0c6a 46
   1398  0c6b		       94 05		      BNZ	A0c71	; 0c6b 94 05
   1399  0c6d		       25 12		      CI	$12	; 0c6d 25 12
   1400  0c6f		       90 03		      BR	A0c73	; 0c6f 90 03
   1401  0c71		       25 0b	   A0c71      CI	$0b	; 0c71 25 0b
   1402  0c73		       92 ec	   A0c73      BNC	A0c60	; 0c73 92 ec
   1403  0c75							; r4 = -(-r6+1+r1)
   1404  0c75		       18		      COM		; 0c75 18
   1405  0c76		       1f		      INC		; 0c76 1f
   1406  0c77		       1f		      INC		; 0c77 1f
   1407  0c78		       c1		      AS	$1	; 0c78 c1
   1408  0c79		       18		      COM		; 0c79 18
   1409  0c7a		       1f		      INC		; 0c7a 1f
   1410  0c7b		       54		      LR	$4,A	; 0c7b 54
   1411  0c7c							; ISAR++ = ((reg_a & 0x30) >> 4) + r4
   1412  0c7c		       20 30		      LI	$30	; 0c7c 20 30
   1413  0c7e		       fa		      NS	$a	; 0c7e fa
   1414  0c7f		       14		      SR	4	; 0c7f 14
   1415  0c80		       c4		      AS	$4	; 0c80 c4
   1416  0c81		       5d		      LR	(IS)+,A	; 0c81 5d
   1417  0c82							; ISAR++ = ((reg_a & 0xC0) >> 6) + r4
   1418  0c82		       20 c0		      LI	$c0	; 0c82 20 c0
   1419  0c84		       fa		      NS	$a	; 0c84 fa
   1420  0c85		       14		      SR	4	; 0c85 14
   1421  0c86		       12		      SR	1	; 0c86 12
   1422  0c87		       12		      SR	1	; 0c87 12
   1423  0c88		       c4		      AS	$4	; 0c88 c4
   1424  0c89		       5d		      LR	(IS)+,A	; 0c89 5d
   1425  0c8a							; ISAR++ = r6 + r2
   1426  0c8a		       46		      LR	A,$6	; 0c8a 46
   1427  0c8b		       c2		      AS	$2	; 0c8b c2
   1428  0c8c		       5d		      LR	(IS)+,A	; 0c8c 5d
   1429  0c8d		       09		      LR	P,K	; 0c8d 09
   1430  0c8e		       1c		      POP		; 0c8e 1c
   1431  0c8f
   1432  0c8f							; Screen Flash
   1433  0c8f							;  Unused function
   1434  0c8f							; Args
   1435  0c8f
   1436  0c8f							; Locals / Clobbers
   1437  0c8f		       00 09	   flash.timer =	9
   1438  0c8f
   1439  0c8f							; Constants
   1440  0c8f		       00 25	   flash.length =	$25
   1441  0c8f
   1442  0c8f							; Returns
   1443  0c8f				   flash
   1444  0c8f		       08		      LR	K,P	; 0c8f 08
   1445  0c90		       20 25		      LI	flash.length	; 0c90 20 25
   1446  0c92		       59		      LR	flash.timer, A	; 0c92 59
   1447  0c93							; if((071 & 0x01) == 0)
   1448  0c93							;  070 = 0x80
   1449  0c93							;  r2 = 0x80
   1450  0c93							; else
   1451  0c93							;  070 = 0xC0
   1452  0c93							;  r2 = 0xC0
   1453  0c93		       67		      LISU	7	; 0c93 67
   1454  0c94		       69		      LISL	1	; 0c94 69
   1455  0c95		       71		      LIS	$1	; 0c95 71
   1456  0c96		       fe		      NS	(IS)-	; 0c96 fe
   1457  0c97		       20 80		      LI	$80	; 0c97 20 80
   1458  0c99		       84 03		      BZ	A0c9d	; 0c99 84 03
   1459  0c9b		       20 c0		      LI	$c0	; 0c9b 20 c0
   1460  0c9d				   A0c9d
   1461  0c9d		       5c		      LR	(IS), A	; 0c9d 5c
   1462  0c9e		       52		      LR	draw.ypos, A	; 0c9e 52
   1463  0c9f				   A0c9f
   1464  0c9f		       4c		      LR	A,(IS)	; 0c9f 4c
   1465  0ca0				   A0ca0
   1466  0ca0							; Set ypos/color
   1467  0ca0		       52		      LR	draw.ypos, A	; 0ca0 52
   1468  0ca1							; Make sound
   1469  0ca1		       4c		      LR	A,(IS)	; 0ca1 4c
   1470  0ca2		       53		      LR	playSound.sound,A	; 0ca2 53
   1471  0ca3		       28 0c c8 	      PI	playSound	; 0ca3 28 0c c8
   1472  0ca6		       68		      LISL	0	; 0ca6 68 ; ???
   1473  0ca7							; Set xpos to attribute column
   1474  0ca7		       20 7d		      LI	gfx.attributeCol	; 0ca7 20 7d
   1475  0ca9		       51		      LR	draw.xpos, A	; 0ca9 51
   1476  0caa							; Set width
   1477  0caa		       72		      LIS	gfx.attributeWidth	; 0caa 72
   1478  0cab		       54		      LR	draw.width, A	; 0cab 54
   1479  0cac							; Set height
   1480  0cac		       20 40		      LI	gfx.screenHeight	; 0cac 20 40
   1481  0cae		       55		      LR	draw.height, A	; 0cae 55
   1482  0caf							; Set rendering properties
   1483  0caf		       20 c0		      LI	draw.drawAttribute	; 0caf 20 c0
   1484  0cb1		       50		      LR	draw.glyph, A	; 0cb1 50
   1485  0cb2		       28 08 62 	      PI	drawBox	; 0cb2 28 08 62
   1486  0cb5
   1487  0cb5							; Clear sound
   1488  0cb5		       70		      LIS	$0	; 0cb5 70
   1489  0cb6		       b5		      OUTS	5	; 0cb6 b5
   1490  0cb7
   1491  0cb7							; Delay
   1492  0cb7		       7b		      LIS	$b	; 0cb7 7b
   1493  0cb8		       50		      LR	delay.count, A	; 0cb8 50
   1494  0cb9		       28 09 9a 	      PI	delay.variable	; 0cb9 28 09 9a
   1495  0cbc
   1496  0cbc		       39		      DS	flash.timer	; 0cbc 39
   1497  0cbd		       91 08		      BM	flash.exit	; 0cbd 91 08
   1498  0cbf
   1499  0cbf							; if (timer is even)
   1500  0cbf							;  ypos/color = (ISAR)
   1501  0cbf							; else
   1502  0cbf							;  ypos/color = 0
   1503  0cbf		       71		      LIS	$1	; 0cbf 71
   1504  0cc0		       f9		      NS	flash.timer	; 0cc0 f9
   1505  0cc1		       70		      LIS	$0	; 0cc1 70
   1506  0cc2		       84 dc		      BZ	A0c9f	; 0cc2 84 dc
   1507  0cc4							; Else set r2 to 0
   1508  0cc4		       90 db		      BR	A0ca0	; 0cc4 90 db
   1509  0cc6
   1510  0cc6				   flash.exit
   1511  0cc6		       09		      LR	P,K	; 0cc6 09
   1512  0cc7		       1c		      POP		; 0cc7 1c
   1513  0cc8
   1514  0cc8							; Play ticking sound when bumping into a wall
   1515  0cc8							; rb - Index of the ball (don't let players make noise?)
   1516  0cc8							; r3 - Sound to be played
   1517  0cc8		       00 03	   playSound.sound =	3
   1518  0cc8
   1519  0cc8				   playSound
   1520  0cc8							; if(curBall < MAX_PLAYERS)
   1521  0cc8							;  play the sound
   1522  0cc8							; return
   1523  0cc8		       4b		      LR	A, main.curBall	; 0cc8 4b
   1524  0cc9		       25 01		      CI	[MAX_PLAYERS-1]	; 0cc9 25 01
   1525  0ccb		       82 03		      BC	playSound.exit	; 0ccb 82 03
   1526  0ccd		       43		      LR	A, playSound.sound	; 0ccd 43
   1527  0cce		       b5		      OUTS	5	; 0cce b5
   1528  0ccf				   playSound.exit
   1529  0ccf		       1c		      POP		; 0ccf 1c
   1530  0cd0
   1531  0cd0							; Init Game
   1532  0cd0				   initRoutine
   1533  0cd0		       67		      LISU	7	; 0cd0 67
   1534  0cd1		       6f		      LISL	7	; 0cd1 6f
   1535  0cd2							; Enable data from controllers ?
   1536  0cd2		       20 40		      LI	$40	; 0cd2 20 40
   1537  0cd4		       b0		      OUTS	0	; 0cd4 b0
   1538  0cd5							; Seed RNG from uninitialized ports
   1539  0cd5		       a4		      INS	4	; 0cd5 a4
   1540  0cd6		       5e		      LR	(IS)-,A	; 0cd6 5e
   1541  0cd7		       a5		      INS	5	; 0cd7 a5
   1542  0cd8		       5e		      LR	(IS)-,A	; 0cd8 5e
   1543  0cd9							; clear o73
   1544  0cd9		       6b		      LISL	3	; 0cd9 6b
   1545  0cda		       70		      LIS	$0	; 0cda 70
   1546  0cdb		       5c		      LR	(IS),A	; 0cdb 5c
   1547  0cdc							; Clear port
   1548  0cdc		       b0		      OUTS	0	; 0cdc b0
   1549  0cdd
   1550  0cdd							; Clear screen
   1551  0cdd							; Set properties
   1552  0cdd		       20 80		      LI	draw.drawRect	; 0cdd 20 80
   1553  0cdf		       50		      LR	draw.glyph, A	; 0cdf 50
   1554  0ce0							; Set x and y pos
   1555  0ce0		       70		      LIS	$0	; 0ce0 70
   1556  0ce1		       51		      LR	draw.xpos, A	; 0ce1 51
   1557  0ce2		       52		      LR	draw.ypos, A	; 0ce2 52
   1558  0ce3							; width = screen width
   1559  0ce3		       20 80		      LI	gfx.screenWidth	; 0ce3 20 80
   1560  0ce5		       54		      LR	draw.width, A	; 0ce5 54
   1561  0ce6							; height = screen height
   1562  0ce6		       20 40		      LI	gfx.screenHeight	; 0ce6 20 40
   1563  0ce8		       55		      LR	draw.height, A	; 0ce8 55
   1564  0ce9		       28 08 62 	      PI	drawBox	; 0ce9 28 08 62
   1565  0cec
   1566  0cec							; Set row attributes
   1567  0cec							; Set rendering properties, ypos, and color
   1568  0cec		       20 c0		      LI	draw.drawAttribute	; 0cec 20 c0
   1569  0cee		       50		      LR	draw.glyph, A	; 0cee 50
   1570  0cef		       52		      LR	draw.ypos, A	; 0cef 52
   1571  0cf0							; Set width
   1572  0cf0		       72		      LIS	gfx.attributeWidth	; 0cf0 72
   1573  0cf1		       54		      LR	draw.width, A	; 0cf1 54
   1574  0cf2							; xpos = attribute column
   1575  0cf2		       20 7d		      LI	gfx.attributeCol	; 0cf2 20 7d
   1576  0cf4		       51		      LR	draw.xpos, A	; 0cf4 51
   1577  0cf5							; Height and ypos are retained from previous write
   1578  0cf5		       28 08 62 	      PI	drawBox	; 0cf5 28 08 62
   1579  0cf8
   1580  0cf8							; Draw the "G?" screen
   1581  0cf8							; glyph = 'G'
   1582  0cf8		       7a		      LIS	$a	; 0cf8 7a
   1583  0cf9		       50		      LR	draw.glyph, A	; 0cf9 50
   1584  0cfa							; xpos
   1585  0cfa		       20 30		      LI	$30	; 0cfa 20 30
   1586  0cfc		       51		      LR	draw.xpos, A	; 0cfc 51
   1587  0cfd							; ypos and color
   1588  0cfd		       20 9b		      LI	$9b	; 0cfd 20 9b
   1589  0cff		       52		      LR	draw.ypos, A	; 0cff 52
   1590  0d00							; width
   1591  0d00		       74		      LIS	$4	; 0d00 74
   1592  0d01		       54		      LR	draw.width, A	; 0d01 54
   1593  0d02							; height
   1594  0d02		       75		      LIS	$5	; 0d02 75
   1595  0d03		       55		      LR	draw.height, A	; 0d03 55
   1596  0d04		       28 08 58 	      PI	drawGlyph	; 0d04 28 08 58
   1597  0d07
   1598  0d07							; glyph = '?'
   1599  0d07		       7b		      LIS	$b	; 0d07 7b
   1600  0d08		       50		      LR	draw.glyph, A	; 0d08 50
   1601  0d09							; x pos
   1602  0d09		       20 35		      LI	$35	; 0d09 20 35
   1603  0d0b		       51		      LR	draw.xpos, A	; 0d0b 51
   1604  0d0c		       28 08 58 	      PI	drawGlyph	; 0d0c 28 08 58
   1605  0d0f
   1606  0d0f							; Menu
   1607  0d0f		       28 08 f0 	      PI	menu	; 0d0f 28 08 f0
   1608  0d12
   1609  0d12							; Load game mode into o75
      0  0d12					      SETISAR	gameMode
      1  0d12		       67		      lisu	[[gameMode] >> 3]
      2  0d13		       6d		      lisl	[[gameMode] & %111]
   1611  0d14							;	      LISU 7		       ; 0d12 67
   1612  0d14							;	     LISL 5		      ; 0d13 6d
   1613  0d14		       12		      SR	1	; 0d14 12
   1614  0d15							; DC was set in the menu
   1615  0d15		       8e		      ADC		; 0d15 8e
   1616  0d16		       16		      LM		; 0d16 16
   1617  0d17		       5c		      LR	(IS),A	; 0d17 5c
   1618  0d18
   1619  0d18							; Shuffle gametype
   1620  0d18				   A0d18
      0  0d18					      SETISAR	gameMode
      1  0d18		       67		      lisu	[[gameMode] >> 3]
      2  0d19		       6d		      lisl	[[gameMode] & %111]
   1622  0d1a							;			LISU 7 		  ; 0d18 67
   1623  0d1a							;		 LISL 5 		  ; 0d19 6d
   1624  0d1a		       4c		      LR	A,(IS)	; 0d1a 4c
   1625  0d1b		       21 03		      NI	$03	; 0d1b 21 03
   1626  0d1d		       5c		      LR	(IS),A	; 0d1d 5c
   1627  0d1e
   1628  0d1e				   A0d1e
   1629  0d1e		       2a 08 43 	      DCI	A0843	; 0d1e 2a 08 43
   1630  0d21		       28 08 c1 	      PI	roll_RNG	; 0d21 28 08 c1
   1631  0d24
   1632  0d24		       16		      LM		; 0d24 16
   1633  0d25		       f6		      NS	RNG.regLo	; 0d25 f6
   1634  0d26		       58		      LR	$8,A	; 0d26 58
   1635  0d27		       16		      LM		; 0d27 16
   1636  0d28		       f6		      NS	RNG.regLo	; 0d28 f6
   1637  0d29		       13		      SL	1	; 0d29 13
   1638  0d2a		       13		      SL	1	; 0d2a 13
   1639  0d2b		       c8		      AS	$8	; 0d2b c8
   1640  0d2c		       92 f1		      BNC	A0d1e	; 0d2c 92 f1
   1641  0d2e
   1642  0d2e		       16		      LM		; 0d2e 16
   1643  0d2f		       f6		      NS	RNG.regLo	; 0d2f f6
   1644  0d30		       84 ed		      BZ	A0d1e	; 0d30 84 ed
   1645  0d32
   1646  0d32		       16		      LM		; 0d32 16
   1647  0d33		       f6		      NS	RNG.regLo	; 0d33 f6
   1648  0d34		       84 e9		      BZ	A0d1e	; 0d34 84 e9
   1649  0d36
   1650  0d36		       46		      LR	A, RNG.regLo	; 0d36 46
   1651  0d37		       5a		      LR	$a,A	; 0d37 5a
   1652  0d38		       16		      LM		; 0d38 16
   1653  0d39		       f7		      NS	RNG.regHi	; 0d39 f7
   1654  0d3a		       cc		      AS	(IS)	; 0d3a cc
   1655  0d3b		       5e		      LR	(IS)-,A	; 0d3b 5e
   1656  0d3c
   1657  0d3c		       2a 08 48 	      DCI	A0848	; 0d3c 2a 08 48
   1658  0d3f		       73		      LIS	$3	; 0d3f 73
   1659  0d40		       fa		      NS	$a	; 0d40 fa
   1660  0d41		       13		      SL	1	; 0d41 13
   1661  0d42		       8e		      ADC		; 0d42 8e
   1662  0d43		       20 58		      LI	$58	; 0d43 20 58
   1663  0d45		       51		      LR	$1,A	; 0d45 51
   1664  0d46		       20 10		      LI	$10	; 0d46 20 10
   1665  0d48		       52		      LR	$2,A	; 0d48 52
   1666  0d49		       66		      LISU	6	; 0d49 66
   1667  0d4a		       68		      LISL	0	; 0d4a 68
   1668  0d4b		       28 0c 5f 	      PI	A0c5f	; 0d4b 28 0c 5f
   1669  0d4e
   1670  0d4e		       20 38		      LI	$38	; 0d4e 20 38
   1671  0d50		       51		      LR	$1,A	; 0d50 51
   1672  0d51		       28 0c 5f 	      PI	A0c5f	; 0d51 28 0c 5f
   1673  0d54
   1674  0d54				   restartGame
   1675  0d54							; Draw playfield
   1676  0d54							; Set rendering properties
   1677  0d54		       20 80		      LI	draw.drawRect	; 0d54 20 80
   1678  0d56		       50		      LR	draw.glyph, A	; 0d56 50
   1679  0d57							; Set x pos
   1680  0d57		       20 10		      LI	$10	; 0d57 20 10
   1681  0d59		       51		      LR	draw.xpos, A	; 0d59 51
   1682  0d5a							; Set ypos and color
   1683  0d5a		       24 80		      AI	$80	; 0d5a 24 80
   1684  0d5c		       52		      LR	draw.ypos, A	; 0d5c 52
   1685  0d5d							; Set width
   1686  0d5d		       20 49		      LI	$49	; 0d5d 20 49
   1687  0d5f		       54		      LR	draw.width, A	; 0d5f 54
   1688  0d60							; Set height
   1689  0d60		       20 29		      LI	$29	; 0d60 20 29
   1690  0d62		       55		      LR	draw.height, A	; 0d62 55
   1691  0d63							; Draw box
   1692  0d63		       28 08 62 	      PI	drawBox	; 0d63 28 08 62
   1693  0d66
   1694  0d66							; Draw inner box
   1695  0d66							; xpos = o62
      0  0d66					      SETISAR	bounds.left	; 0d66 66 6a
      1  0d66		       66		      lisu	[[bounds.left] >> 3]
      2  0d67		       6a		      lisl	[[bounds.left] & %111]
   1697  0d68		       4c		      LR	A,(IS)	; 0d68 4c
   1698  0d69		       51		      LR	draw.xpos, A	; 0d69 51
   1699  0d6a							; width = -(o62 + o60)
      0  0d6a					      SETISARL	bounds.rightEnemy	; 0d6a 68
      1  0d6a		       68		      lisl	[[bounds.rightEnemy] & %111]
   1701  0d6b		       cc		      AS	(IS)	; 0d6b cc
   1702  0d6c		       18		      COM		; 0d6c 18
   1703  0d6d		       1f		      INC		; 0d6d 1f
   1704  0d6e		       54		      LR	draw.width, A	; 0d6e 54
   1705  0d6f							; r3 = (reg_a & $30) >> 4 // VERIFY: reg_a contains the player's size
   1706  0d6f							; width += r3
   1707  0d6f		       20 30		      LI	$30	; 0d6f 20 30
   1708  0d71		       fa		      NS	$a	; 0d71 fa
   1709  0d72		       14		      SR	4	; 0d72 14
   1710  0d73		       53		      LR	$3,A	; 0d73 53
   1711  0d74		       c4		      AS	draw.width	; 0d74 c4
   1712  0d75		       54		      LR	draw.width, A	; 0d75 54
   1713  0d76							; set ypos (color is blank)
      0  0d76					      SETISARL	bounds.top	; 0d76 6d
      1  0d76		       6d		      lisl	[[bounds.top] & %111]
   1715  0d77		       4c		      LR	A,(IS)	; 0d77 4c
   1716  0d78		       52		      LR	draw.ypos, A	; 0d78 52
   1717  0d79							; height = -(top - bottom) + temp // temp is player size
      0  0d79					      SETISARL	bounds.bottomEnemy	; 0d79 6b
      1  0d79		       6b		      lisl	[[bounds.bottomEnemy] & %111]
   1719  0d7a		       cc		      AS	(IS)	; 0d7a cc
   1720  0d7b		       18		      COM		; 0d7b 18
   1721  0d7c		       1f		      INC		; 0d7c 1f
   1722  0d7d		       c3		      AS	$3	; 0d7d c3
   1723  0d7e		       55		      LR	draw.height, A	; 0d7e 55
   1724  0d7f							; Set rendering properties
   1725  0d7f		       20 80		      LI	draw.drawRect	; 0d7f 20 80
   1726  0d81		       50		      LR	draw.glyph, A	; 0d81 50
   1727  0d82		       28 08 62 	      PI	drawBox	; 0d82 28 08 62
   1728  0d85
   1729  0d85							; timer = 0
      0  0d85					      SETISAR	timer.hiByte	; 0d85 66 6e
      1  0d85		       66		      lisu	[[timer.hiByte] >> 3]
      2  0d86		       6e		      lisl	[[timer.hiByte] & %111]
   1731  0d87		       70		      LIS	$0	; 0d87 70
   1732  0d88		       5d		      LR	(IS)+,A	; 0d88 5d
   1733  0d89		       5d		      LR	(IS)+,A	; 0d89 5d
   1734  0d8a
   1735  0d8a							; Do something for 2 balls?
   1736  0d8a		       70		      LIS	$0	; 0d8a 70
   1737  0d8b				   A0d8b
   1738  0d8b		       5b		      LR	main.curBall, A	; 0d8b 5b
   1739  0d8c		       28 09 c2 	      PI	maybeSpawn	; 0d8c 28 09 c2
   1740  0d8f		       4b		      LR	A, main.curBall	; 0d8f 4b
   1741  0d90		       1f		      INC		; 0d90 1f
   1742  0d91		       25 01		      CI	[MAX_PLAYERS-1]	; 0d91 25 01
   1743  0d93		       82 f7		      BC	A0d8b	; 0d93 82 f7
   1744  0d95
   1745  0d95							; o56 = num_balls?
   1746  0d95		       65		      LISU	5	; 0d95 65
   1747  0d96		       6e		      LISL	6	; 0d96 6e
   1748  0d97		       5c		      LR	(IS),A	; 0d97 5c
   1749  0d98		       5b		      LR	main.curBall, A	; 0d98 5b
   1750  0d99		       28 09 c2 	      PI	maybeSpawn	; 0d99 28 09 c2
   1751  0d9c
   1752  0d9c		       67		      LISU	7	; 0d9c 67
   1753  0d9d		       6a		      LISL	2	; 0d9d 6a
   1754  0d9e		       70		      LIS	$0	; 0d9e 70
   1755  0d9f		       5c		      LR	(IS),A	; 0d9f 5c
   1756  0da0
   1757  0da0							; MAIN LOOP
   1758  0da0				   mainLoop
   1759  0da0							; Clear sound
   1760  0da0		       70		      LIS	$0	; 0da0 70
   1761  0da1		       b5		      OUTS	5	; 0da1 b5
   1762  0da2
   1763  0da2							; Change num ball according to timer?
   1764  0da2		       66		      LISU	6	; 0da2 66
   1765  0da3		       6e		      LISL	6	; 0da3 6e
   1766  0da4		       4d		      LR	A,(IS)+	; 0da4 4d
   1767  0da5		       1f		      INC		; 0da5 1f
   1768  0da6		       25 0a		      CI	$0a	; 0da6 25 0a
   1769  0da8		       82 02		      BC	A0dab	; 0da8 82 02
   1770  0daa		       7a		      LIS	$a	; 0daa 7a
   1771  0dab		       65	   A0dab      LISU	5	; 0dab 65
   1772  0dac		       5c		      LR	(IS),A	; 0dac 5c
   1773  0dad		       66		      LISU	6	; 0dad 66
   1774  0dae
   1775  0dae							; Increment 16-bit BCD timer
   1776  0dae							; ISAR is 067 here
   1777  0dae							; BCD increment
   1778  0dae		       20 67		      LI	$67	; 0dae 20 67
   1779  0db0		       dc		      ASD	(IS)	; 0db0 dc
   1780  0db1		       5e		      LR	(IS)-,A	; 0db1 5e
   1781  0db2		       92 12		      BNC	A0dc5	; 0db2 92 12
   1782  0db4							; Continue if tens carry over
   1783  0db4		       20 67		      LI	$67	; 0db4 20 67
   1784  0db6		       dc		      ASD	(IS)	; 0db6 dc
   1785  0db7		       5d		      LR	(IS)+,A	; 0db7 5d
   1786  0db8		       21 0f		      NI	$0f	; 0db8 21 0f
   1787  0dba		       94 0a		      BNZ	A0dc5	; 0dba 94 0a
   1788  0dbc							; Continue if hundreds are zero
   1789  0dbc		       70		      LIS	$0	; 0dbc 70
   1790  0dbd		       cc		      AS	(IS)	; 0dbd cc
   1791  0dbe		       94 06		      BNZ	A0dc5	; 0dbe 94 06
   1792  0dc0							; Continue if tens and ones are both zero
   1793  0dc0							; o72 = 0x80 ; Set explosion flag
   1794  0dc0		       67		      LISU	7	; 0dc0 67
   1795  0dc1		       6a		      LISL	2	; 0dc1 6a
   1796  0dc2		       20 80		      LI	$80	; 0dc2 20 80
   1797  0dc4		       5c		      LR	(IS),A	; 0dc4 5c
   1798  0dc5
   1799  0dc5				   A0dc5
   1800  0dc5							; Display timer
   1801  0dc5							; Check if 1 or 2 player
      0  0dc5					      SETISAR	gameMode	; 0dc5 67 6d
      1  0dc5		       67		      lisu	[[gameMode] >> 3]
      2  0dc6		       6d		      lisl	[[gameMode] & %111]
   1803  0dc7		       71		      LIS	mode.2playerMask	; 0dc7 71
   1804  0dc8		       fc		      NS	(IS)	; 0dc8 fc
   1805  0dc9							; Display in middle if 2 player mode
   1806  0dc9		       20 39		      LI	$39	; 0dc9 20 39
   1807  0dcb		       94 03		      BNZ	A0dcf	; 0dcb 94 03
   1808  0dcd							; Display to left if 1 player mode
   1809  0dcd		       20 1f		      LI	$1f	; 0dcd 20 1f
   1810  0dcf				   A0dcf
   1811  0dcf		       50		      LR	drawTimer.xpos, A	; 0dcf 50
   1812  0dd0							; Set y pos (or color ?)
   1813  0dd0		       20 80		      LI	$80	; 0dd0 20 80
   1814  0dd2		       52		      LR	drawTimer.ypos, A	; 0dd2 52
   1815  0dd3							; Set ISAR to LSB of score
      0  0dd3					      SETISAR	timer.loByte	; 0dd3 66 6f
      1  0dd3		       66		      lisu	[[timer.loByte] >> 3]
      2  0dd4		       6f		      lisl	[[timer.loByte] & %111]
   1817  0dd5		       28 0a 20 	      PI	drawTimer	; 0dd5 28 0a 20
   1818  0dd8
   1819  0dd8		       65		      LISU	5	; 0dd8 65
   1820  0dd9		       6f		      LISL	7	; 0dd9 6f
   1821  0dda		       4c		      LR	A,(IS)	; 0dda 4c
   1822  0ddb		       50		      LR	delay.index, A	; 0ddb 50
   1823  0ddc							; Wait
   1824  0ddc		       28 09 86 	      PI	delay.viaLookup	; 0ddc 28 09 86
   1825  0ddf							; rb = o56 (ball count)
   1826  0ddf		       65		      LISU	5	; 0ddf 65
   1827  0de0		       6e		      LISL	6	; 0de0 6e
   1828  0de1		       20 0f		      LI	$0f	; 0de1 20 0f
   1829  0de3		       fd		      NS	(IS)+	; 0de3 fd
   1830  0de4		       5b		      LR	main.curBall, A	; 0de4 5b
   1831  0de5		       4c		      LR	A,(IS)	; 0de5 4c
   1832  0de6		       18		      COM		; 0de6 18
   1833  0de7		       1f		      INC		; 0de7 1f
   1834  0de8		       cb		      AS	$b	; 0de8 cb
   1835  0de9		       81 0d		      BP	A0df7	; 0de9 81 0d
   1836  0deb
   1837  0deb		       4c		      LR	A,(IS)	; 0deb 4c
   1838  0dec		       5b		      LR	main.curBall, A	; 0dec 5b
   1839  0ded		       28 09 c2 	      PI	maybeSpawn	; 0ded 28 09 c2
   1840  0df0
   1841  0df0		       65		      LISU	5	; 0df0 65
   1842  0df1		       6e		      LISL	6	; 0df1 6e
   1843  0df2		       20 f0		      LI	$f0	; 0df2 20 f0
   1844  0df4		       fd		      NS	(IS)+	; 0df4 fd
   1845  0df5		       ce		      AS	(IS)-	; 0df5 ce
   1846  0df6		       5c		      LR	(IS),A	; 0df6 5c
   1847  0df7		       65	   A0df7      LISU	5	; 0df7 65
   1848  0df8		       6e		      LISL	6	; 0df8 6e
   1849  0df9		       20 0f		      LI	$0f	; 0df9 20 0f
   1850  0dfb		       fc		      NS	(IS)	; 0dfb fc
   1851  0dfc		       5b		      LR	main.curBall, A	; 0dfc 5b
   1852  0dfd		       67	   A0dfd      LISU	7	; 0dfd 67
   1853  0dfe		       68		      LISL	0	; 0dfe 68
   1854  0dff		       20 30		      LI	$30	; 0dff 20 30
   1855  0e01		       fa		      NS	$a	; 0e01 fa
   1856  0e02		       14		      SR	4	; 0e02 14
   1857  0e03		       5d		      LR	(IS)+,A	; 0e03 5d
   1858  0e04		       20 03		      LI	$03	; 0e04 20 03
   1859  0e06		       fa		      NS	$a	; 0e06 fa
   1860  0e07		       5c		      LR	(IS),A	; 0e07 5c
   1861  0e08		       28 0a 53 	      PI	handleBall	; 0e08 28 0a 53
   1862  0e0b							; Collision ?
   1863  0e0b		       28 0b 6e 	      PI	ballCollision	; 0e0b 28 0b 6e
   1864  0e0e
   1865  0e0e		       3b		      DS	$b	; 0e0e 3b
   1866  0e0f		       4b		      LR	A,$b	; 0e0f 4b
   1867  0e10		       25 01		      CI	$01	; 0e10 25 01
   1868  0e12		       92 ea		      BNC	A0dfd	; 0e12 92 ea
   1869  0e14
   1870  0e14		       28 09 24 	      PI	playerHandler	; 0e14 28 09 24
   1871  0e17
   1872  0e17		       67		      LISU	7	; 0e17 67
   1873  0e18		       68		      LISL	0	; 0e18 68
   1874  0e19		       20 c0		      LI	$c0	; 0e19 20 c0
   1875  0e1b		       fa		      NS	$a	; 0e1b fa
   1876  0e1c		       14		      SR	4	; 0e1c 14
   1877  0e1d		       12		      SR	1	; 0e1d 12
   1878  0e1e		       12		      SR	1	; 0e1e 12
   1879  0e1f		       5d		      LR	(IS)+,A	; 0e1f 5d
   1880  0e20		       20 0c		      LI	$0c	; 0e20 20 0c
   1881  0e22		       fa		      NS	$a	; 0e22 fa
   1882  0e23		       12		      SR	1	; 0e23 12
   1883  0e24		       12		      SR	1	; 0e24 12
   1884  0e25		       5c		      LR	(IS),A	; 0e25 5c
   1885  0e26		       20 00		      LI	$00	; 0e26 20 00
   1886  0e28		       5b		      LR	$b,A	; 0e28 5b
   1887  0e29		       28 0a 53 	      PI	handleBall	; 0e29 28 0a 53
   1888  0e2c
      0  0e2c					      SETISAR	gameMode
      1  0e2c		       67		      lisu	[[gameMode] >> 3]
      2  0e2d		       6d		      lisl	[[gameMode] & %111]
   1890  0e2e							;		  LISU 7		   ; 0e2c 67
   1891  0e2e							;		 LISL 5 		  ; 0e2d 6d
   1892  0e2e		       71		      LIS	$1	; 0e2e 71
   1893  0e2f		       fc		      NS	(IS)	; 0e2f fc
   1894  0e30		       84 05		      BZ	A0e36	; 0e30 84 05
   1895  0e32
   1896  0e32		       5b		      LR	$b,A	; 0e32 5b
   1897  0e33		       28 0a 53 	      PI	handleBall	; 0e33 28 0a 53
   1898  0e36
   1899  0e36							; Loop back to beginning if explosion flag isn't set
   1900  0e36		       67	   A0e36      LISU	7	; 0e36 67
   1901  0e37		       6a		      LISL	2	; 0e37 6a
   1902  0e38		       70		      LIS	$0	; 0e38 70
   1903  0e39		       cc		      AS	(IS)	; 0e39 cc
   1904  0e3a		       81 06		      BP	A0e41	; 0e3a 81 06
   1905  0e3c							; Clear explosion flag, and then explode
   1906  0e3c		       70		      LIS	$0	; 0e3c 70
   1907  0e3d		       5c		      LR	(IS),A	; 0e3d 5c
   1908  0e3e		       29 0f 6b 	      JMP	explode	; 0e3e 29 0f 6b
   1909  0e41							; Loop back
   1910  0e41				   A0e41
   1911  0e41		       29 0d a0 	      JMP	mainLoop	; 0e41 29 0d a0
   1912  0e44
   1913  0e44							; Game Over / Death Animation
   1914  0e44				   gameOver
   1915  0e44							; ypos = $24
   1916  0e44							; color = $80
   1917  0e44		       20 a4		      LI	$a4	; 0e44 20 a4
   1918  0e46		       52		      LR	draw.ypos, A	; 0e46 52
   1919  0e47							; o46 = $14 (spiral radius?)
   1920  0e47		       64		      LISU	4	; 0e47 64
   1921  0e48		       6e		      LISL	6	; 0e48 6e
   1922  0e49		       20 14		      LI	$14	; 0e49 20 14
   1923  0e4b		       5c		      LR	(IS),A	; 0e4b 5c
   1924  0e4c				   gameOver.spiralLoop
   1925  0e4c		       28 0f 0a 	      PI	drawSpiral	; 0e4c 28 0f 0a
   1926  0e4f							; o46--
   1927  0e4f		       64		      LISU	4	; 0e4f 64
   1928  0e50		       6e		      LISL	6	; 0e50 6e
   1929  0e51		       3c		      DS	(IS)	; 0e51 3c
   1930  0e52							; save flags
   1931  0e52		       1e		      LR	J,W	; 0e52 1e
   1932  0e53							; color++
   1933  0e53							; if(color == 0)
   1934  0e53							;  color++
   1935  0e53							; ypos = $24
   1936  0e53		       42		      LR	A, draw.ypos	; 0e53 42
   1937  0e54		       24 40		      AI	$40	; 0e54 24 40
   1938  0e56		       92 03		      BNC	A0e5a	; 0e56 92 03
   1939  0e58		       24 40		      AI	$40	; 0e58 24 40
   1940  0e5a				   A0e5a
   1941  0e5a		       21 c0		      NI	$c0	; 0e5a 21 c0
   1942  0e5c		       24 24		      AI	$24	; 0e5c 24 24
   1943  0e5e		       52		      LR	draw.ypos,A	; 0e5e 52
   1944  0e5f							; restore flags
   1945  0e5f							; loop back if o46 != 0
   1946  0e5f		       1d		      LR	W,J	; 0e5f 1d
   1947  0e60		       94 eb		      BNZ	gameOver.spiralLoop	; 0e60 94 eb
   1948  0e62
   1949  0e62							; delay.variable($0)
   1950  0e62		       70		      LIS	$0	; 0e62 70
   1951  0e63		       50		      LR	delay.count, A	; 0e63 50
   1952  0e64		       28 09 9a 	      PI	delay.variable	; 0e64 28 09 9a
   1953  0e67
   1954  0e67							; Set color depending on who died
   1955  0e67							; 1P - Red
   1956  0e67							; 2P, player 1 - Green
   1957  0e67							; 2P, player 2 - Blue
      0  0e67					      SETISAR	gameMode
      1  0e67		       67		      lisu	[[gameMode] >> 3]
      2  0e68		       6d		      lisl	[[gameMode] & %111]
   1959  0e69							;		  LISU 7		   ; 0e67 67
   1960  0e69							;		  LISL 5		   ; 0e68 6d
   1961  0e69		       71		      LIS	$1	; 0e69 71
   1962  0e6a		       fc		      NS	(IS)	; 0e6a fc
   1963  0e6b		       20 80		      LI	$80	; 0e6b 20 80
   1964  0e6d		       84 0a		      BZ	A0e78	; 0e6d 84 0a
   1965  0e6f		       69		      LISL	1	; 0e6f 69
   1966  0e70		       71		      LIS	$1	; 0e70 71
   1967  0e71		       fc		      NS	(IS)	; 0e71 fc
   1968  0e72		       20 c0		      LI	$c0	; 0e72 20 c0
   1969  0e74		       84 03		      BZ	A0e78	; 0e74 84 03
   1970  0e76		       20 40		      LI	$40	; 0e76 20 40
   1971  0e78		       24 24	   A0e78      AI	$24	; 0e78 24 24
   1972  0e7a		       52		      LR	$2,A	; 0e7a 52
   1973  0e7b		       64		      LISU	4	; 0e7b 64
   1974  0e7c		       6e		      LISL	6	; 0e7c 6e
   1975  0e7d		       20 14		      LI	$14	; 0e7d 20 14
   1976  0e7f		       5c		      LR	(IS),A	; 0e7f 5c
   1977  0e80		       28 0f 0a 	      PI	drawSpiral	; 0e80 28 0f 0a
   1978  0e83
   1979  0e83							; Delay
   1980  0e83		       20 28		      LI	$28	; 0e83 20 28
   1981  0e85		       50		      LR	delay.count,A	; 0e85 50
   1982  0e86		       28 09 9a 	      PI	delay.variable	; 0e86 28 09 9a
   1983  0e89
   1984  0e89							; Check if two players
      0  0e89					      SETISAR	gameMode	; 0e89 67 6d
      1  0e89		       67		      lisu	[[gameMode] >> 3]
      2  0e8a		       6d		      lisl	[[gameMode] & %111]
   1986  0e8b		       71		      LIS	mode.2playerMask	; 0e8b 71
   1987  0e8c		       fc		      NS	(IS)	; 0e8c fc
   1988  0e8d							; If so, jump ahead
   1989  0e8d		       94 38		      BNZ	A0ec6	; 0e8d 94 38
   1990  0e8f							; One player case
   1991  0e8f							; r6/r7 = timer
   1992  0e8f		       66		      LISU	6	; 0e8f 66
   1993  0e90		       6e		      LISL	6	; 0e90 6e
   1994  0e91		       4d		      LR	A,(IS)+	; 0e91 4d
   1995  0e92		       56		      LR	$6,A	; 0e92 56
   1996  0e93		       4c		      LR	A,(IS)	; 0e93 4c
   1997  0e94		       57		      LR	$7,A	; 0e94 57
   1998  0e95							; If timer >= hi_score
   1999  0e95							;  then replace hi_score
   2000  0e95		       65		      LISU	5	; 0e95 65
   2001  0e96		       6c		      LISL	4	; 0e96 6c
   2002  0e97		       4d		      LR	A,(IS)+	; 0e97 4d
   2003  0e98		       18		      COM		; 0e98 18
   2004  0e99		       1f		      INC		; 0e99 1f
   2005  0e9a		       c6		      AS	$6	; 0e9a c6
   2006  0e9b		       91 16		      BM	A0eb2	; 0e9b 91 16
   2007  0e9d		       94 07		      BNZ	A0ea5	; 0e9d 94 07
   2008  0e9f		       4c		      LR	A,(IS)	; 0e9f 4c
   2009  0ea0		       18		      COM		; 0ea0 18
   2010  0ea1		       1f		      INC		; 0ea1 1f
   2011  0ea2		       c7		      AS	$7	; 0ea2 c7
   2012  0ea3		       91 0e		      BM	A0eb2	; 0ea3 91 0e
   2013  0ea5
   2014  0ea5							; Draw score
   2015  0ea5		       47	   A0ea5      LR	A,$7	; 0ea5 47
   2016  0ea6		       5e		      LR	(IS)-,A	; 0ea6 5e
   2017  0ea7		       46		      LR	A,$6	; 0ea7 46
   2018  0ea8		       5d		      LR	(IS)+,A	; 0ea8 5d
   2019  0ea9							; Set color
   2020  0ea9		       20 40		      LI	$40	; 0ea9 20 40
   2021  0eab		       52		      LR	draw.ypos, A	; 0eab 52
   2022  0eac							; Set glyph
   2023  0eac		       20 54		      LI	$54	; 0eac 20 54
   2024  0eae		       50		      LR	draw.glyph, A	; 0eae 50
   2025  0eaf		       28 0a 20 	      PI	drawTimer	; 0eaf 28 0a 20
   2026  0eb2				   A0eb2
   2027  0eb2							; Delay
   2028  0eb2		       20 40		      LI	$40	; 0eb2 20 40
   2029  0eb4		       50		      LR	delay.count, A	; 0eb4 50
   2030  0eb5		       28 09 9a 	      PI	delay.variable	; 0eb5 28 09 9a
   2031  0eb8							; Read controllers
   2032  0eb8		       28 09 10 	      PI	readControllers	; 0eb8 28 09 10
   2033  0ebb							; If controller is pushed, keep gametype?
   2034  0ebb		       68		      LISL	0	; 0ebb 68
   2035  0ebc		       70		      LIS	$0	; 0ebc 70
   2036  0ebd		       cc		      AS	(IS)	; 0ebd cc
   2037  0ebe		       91 04		      BM	A0ec3	; 0ebe 91 04
   2038  0ec0		       29 0d 54 	      JMP	restartGame	; 0ec0 29 0d 54
   2039  0ec3							; Shuffle gametype
   2040  0ec3		       29 0d 18    A0ec3      JMP	A0d18	; 0ec3 29 0d 18
   2041  0ec6
   2042  0ec6							; Two player case
   2043  0ec6				   A0ec6		; r6/r7 = timer
   2044  0ec6		       66		      LISU	6	; 0ec6 66
   2045  0ec7		       6e		      LISL	6	; 0ec7 6e
   2046  0ec8		       4d		      LR	A,(IS)+	; 0ec8 4d
   2047  0ec9		       56		      LR	$6,A	; 0ec9 56
   2048  0eca		       4c		      LR	A,(IS)	; 0eca 4c
   2049  0ecb		       57		      LR	$7,A	; 0ecb 57
   2050  0ecc
   2051  0ecc		       67		      LISU	7	; 0ecc 67
   2052  0ecd		       69		      LISL	1	; 0ecd 69
   2053  0ece		       71		      LIS	$1	; 0ece 71
   2054  0ecf		       fc		      NS	(IS)	; 0ecf fc
   2055  0ed0		       94 0b		      BNZ	A0edc	; 0ed0 94 0b
   2056  0ed2							; set ypos (or maybe color?)
   2057  0ed2		       20 c0		      LI	$c0	; 0ed2 20 c0
   2058  0ed4		       52		      LR	$2,A	; 0ed4 52
   2059  0ed5							; set xpos
   2060  0ed5		       20 54		      LI	$54	; 0ed5 20 54
   2061  0ed7		       50		      LR	$0,A	; 0ed7 50
   2062  0ed8		       67		      LISU	7	; 0ed8 67
   2063  0ed9		       6c		      LISL	4	; 0ed9 6c
   2064  0eda		       90 09		      BR	A0ee4	; 0eda 90 09
   2065  0edc
   2066  0edc		       65	   A0edc      LISU	5	; 0edc 65
   2067  0edd		       6d		      LISL	5	; 0edd 6d
   2068  0ede							; set ypos (or maybe color?)
   2069  0ede		       20 40		      LI	$40	; 0ede 20 40
   2070  0ee0		       52		      LR	$2,A	; 0ee0 52
   2071  0ee1							; set xpos
   2072  0ee1		       20 1f		      LI	$1f	; 0ee1 20 1f
   2073  0ee3		       50		      LR	$0,A	; 0ee3 50
   2074  0ee4
   2075  0ee4		       47	   A0ee4      LR	A,$7	; 0ee4 47
   2076  0ee5		       cc		      AS	(IS)	; 0ee5 cc
   2077  0ee6		       5c		      LR	(IS),A	; 0ee6 5c
   2078  0ee7		       20 66		      LI	$66	; 0ee7 20 66
   2079  0ee9		       dc		      ASD	(IS)	; 0ee9 dc
   2080  0eea		       5e		      LR	(IS)-,A	; 0eea 5e
   2081  0eeb		       92 05		      BNC	A0ef1	; 0eeb 92 05
   2082  0eed
   2083  0eed		       20 67		      LI	$67	; 0eed 20 67
   2084  0eef		       dc		      ASD	(IS)	; 0eef dc
   2085  0ef0		       5c		      LR	(IS),A	; 0ef0 5c
   2086  0ef1		       4c	   A0ef1      LR	A,(IS)	; 0ef1 4c
   2087  0ef2		       c6		      AS	$6	; 0ef2 c6
   2088  0ef3		       5c		      LR	(IS),A	; 0ef3 5c
   2089  0ef4		       20 66		      LI	$66	; 0ef4 20 66
   2090  0ef6		       dc		      ASD	(IS)	; 0ef6 dc
   2091  0ef7		       5d		      LR	(IS)+,A	; 0ef7 5d
   2092  0ef8		       28 0a 20 	      PI	drawTimer	; 0ef8 28 0a 20 ; Score display
   2093  0efb							; Read controllers
   2094  0efb		       28 09 10 	      PI	readControllers	; 0efb 28 09 10
   2095  0efe							; If neither player is touching anything, shuffle gametype
   2096  0efe		       68		      LISL	0	; 0efe 68
   2097  0eff		       70		      LIS	$0	; 0eff 70
   2098  0f00		       cd		      AS	(IS)+	; 0f00 cd
   2099  0f01		       91 c1		      BM	A0ec3	; 0f01 91 c1
   2100  0f03		       70		      LIS	$0	; 0f03 70
   2101  0f04		       cc		      AS	(IS)	; 0f04 cc
   2102  0f05		       91 bd		      BM	A0ec3	; 0f05 91 bd
   2103  0f07							; Else, just restart the current game
   2104  0f07		       29 0d 54 	      JMP	restartGame	; 0f07 29 0d 54
   2105  0f0a
   2106  0f0a							; Death animation ?
   2107  0f0a							; Draw Box
   2108  0f0a							; r1 - X pos
   2109  0f0a							; r2 - Y pos + something else?
   2110  0f0a							; r4 - Width
   2111  0f0a							; r5 - Height
   2112  0f0a				   drawSpiral
   2113  0f0a		       08		      LR	K,P	; 0f0a 08
   2114  0f0b							; Set properties to draw a rect
   2115  0f0b		       20 80		      LI	draw.drawRect	; 0f0b 20 80
   2116  0f0d		       50		      LR	draw.glyph, A	; 0f0d 50
   2117  0f0e							; xpos = $34
   2118  0f0e							; Note: ypos is set before entering this function
   2119  0f0e		       20 34		      LI	$34	; 0f0e 20 34
   2120  0f10		       51		      LR	draw.xpos, A	; 0f10 51
   2121  0f11		       62		      LISU	2	; 0f11 62
   2122  0f12		       6c		      LISL	4	; 0f12 6c
   2123  0f13							; Set width/height to 1
   2124  0f13		       71		      LIS	$1	; 0f13 71
   2125  0f14		       54		      LR	draw.width, A	; 0f14 54
   2126  0f15		       55		      LR	draw.height, A	; 0f15 55
   2127  0f16							; Set o24, o25, o26, o27 to 1
   2128  0f16		       5d		      LR	(IS)+,A	; 0f16 5d
   2129  0f17		       5d		      LR	(IS)+,A	; 0f17 5d
   2130  0f18		       5d		      LR	(IS)+,A	; 0f18 5d
   2131  0f19		       5e		      LR	(IS)-,A	; 0f19 5e
   2132  0f1a							; o36 = o46
   2133  0f1a		       64		      LISU	4	; 0f1a 64
   2134  0f1b		       4c		      LR	A,(IS)	; 0f1b 4c
   2135  0f1c		       63		      LISU	3	; 0f1c 63
   2136  0f1d		       5c		      LR	(IS),A	; 0f1d 5c
   2137  0f1e							; isar = o26
   2138  0f1e		       62		      LISU	2	; 0f1e 62
   2139  0f1f							; a = 2
   2140  0f1f		       71		      LIS	$1	; 0f1f 71
   2141  0f20		       13		      SL	1	; 0f20 13
   2142  0f21		       1e		      LR	J,W	; 0f21 1e ; save flags
   2143  0f22							; Draw
   2144  0f22		       28 08 62 	      PI	drawBox	; 0f22 28 08 62
   2145  0f25				   drawSpiral.label_1		; plot up
   2146  0f25							; ypos = ypos - 1
   2147  0f25		       32		      DS	draw.ypos	; 0f25 32
   2148  0f26		       28 08 62 	      PI	drawBox	; 0f26 28 08 62
   2149  0f29							; o26 = o26 - 1
   2150  0f29		       3c		      DS	(IS)	; 0f29 3c
   2151  0f2a							; Loop until o26 reaches 0
   2152  0f2a		       94 fa		      BNZ	drawSpiral.label_1	; 0f2a 94 fa
   2153  0f2c
   2154  0f2c		       1d		      LR	W,J	; 0f2c 1d ; restore flags
   2155  0f2d							; goto exit if zero flag is set
   2156  0f2d		       84 3b		      BZ	A0f69	; 0f2d 84 3b
   2157  0f2f							; o27 = o27 + 1
   2158  0f2f		       4d		      LR	A,(IS)+	; 0f2f 4d
   2159  0f30		       4c		      LR	A,(IS)	; 0f30 4c
   2160  0f31		       1f		      INC		; 0f31 1f
   2161  0f32		       5e		      LR	(IS)-,A	; 0f32 5e
   2162  0f33							; o26 = o27
   2163  0f33		       5e		      LR	(IS)-,A	; 0f33 5e
   2164  0f34				   drawSpiral.label_2		; plot right
   2165  0f34							; xpos++
   2166  0f34		       41		      LR	A, draw.xpos	; 0f34 41
   2167  0f35		       1f		      INC		; 0f35 1f
   2168  0f36		       51		      LR	draw.xpos, A	; 0f36 51
   2169  0f37							; plot
   2170  0f37		       28 08 62 	      PI	drawBox	; 0f37 28 08 62
   2171  0f3a							; o25--
   2172  0f3a		       3c		      DS	(IS)	; 0f3a 3c
   2173  0f3b							; loop until o25 reaches 0
   2174  0f3b		       94 f8		      BNZ	drawSpiral.label_2	; 0f3b 94 f8
   2175  0f3d							; Clear sound
   2176  0f3d		       70		      LIS	$0	; 0f3d 70
   2177  0f3e		       b5		      OUTS	5	; 0f3e b5
   2178  0f3f							; o24 = o24 + 1
   2179  0f3f		       4e		      LR	A,(IS)-	; 0f3f 4e
   2180  0f40		       4c		      LR	A,(IS)	; 0f40 4c
   2181  0f41		       1f		      INC		; 0f41 1f
   2182  0f42		       5d		      LR	(IS)+,A	; 0f42 5d
   2183  0f43							; o25 = o24
   2184  0f43		       5d		      LR	(IS)+,A	; 0f43 5d
   2185  0f44				   drawSpiral.label_3		; plot down ?
   2186  0f44							; ypos++
   2187  0f44		       42		      LR	A, draw.ypos	; 0f44 42
   2188  0f45		       1f		      INC		; 0f45 1f
   2189  0f46		       52		      LR	draw.ypos, A	; 0f46 52
   2190  0f47							; plot
   2191  0f47		       28 08 62 	      PI	drawBox	; 0f47 28 08 62
   2192  0f4a							; o26-- ?
   2193  0f4a		       3c		      DS	(IS)	; 0f4a 3c
   2194  0f4b
   2195  0f4b		       94 f8		      BNZ	drawSpiral.label_3	; 0f4b 94 f8
   2196  0f4d		       4d		      LR	A,(IS)+	; 0f4d 4d
   2197  0f4e		       4c		      LR	A,(IS)	; 0f4e 4c
   2198  0f4f		       1f		      INC		; 0f4f 1f
   2199  0f50		       5e		      LR	(IS)-,A	; 0f50 5e
   2200  0f51		       5e		      LR	(IS)-,A	; 0f51 5e
   2201  0f52				   drawSpiral.label_4		; plot left ?
   2202  0f52							; xpos--
   2203  0f52		       31		      DS	draw.xpos	; 0f52 31
   2204  0f53							; plot
   2205  0f53		       28 08 62 	      PI	drawBox	; 0f53 28 08 62
   2206  0f56		       3c		      DS	(IS)	; 0f56 3c
   2207  0f57		       94 fa		      BNZ	drawSpiral.label_4	; 0f57 94 fa
   2208  0f59		       4e		      LR	A,(IS)-	; 0f59 4e
   2209  0f5a		       4c		      LR	A,(IS)	; 0f5a 4c
   2210  0f5b		       1f		      INC		; 0f5b 1f
   2211  0f5c		       5d		      LR	(IS)+,A	; 0f5c 5d
   2212  0f5d		       5d		      LR	(IS)+,A	; 0f5d 5d
   2213  0f5e
   2214  0f5e		       63		      LISU	3	; 0f5e 63
   2215  0f5f		       3c		      DS	(IS)	; 0f5f 3c
   2216  0f60		       62		      LISU	2	; 0f60 62
   2217  0f61		       1e		      LR	J,W	; 0f61 1e ; reload flags
   2218  0f62							; Play sound ?
   2219  0f62		       42		      LR	A,$2	; 0f62 42
   2220  0f63		       b5		      OUTS	5	; 0f63 b5
   2221  0f64
   2222  0f64		       94 c0		      BNZ	drawSpiral.label_1	; 0f64 94 c0
   2223  0f66
   2224  0f66		       3c		      DS	(IS)	; 0f66 3c
   2225  0f67		       90 bd		      BR	drawSpiral.label_1	; 0f67 90 bd
   2226  0f69							; Return
   2227  0f69		       09	   A0f69      LR	P,K	; 0f69 09
   2228  0f6a		       1c		      POP		; 0f6a 1c
   2229  0f6b
   2230  0f6b							; Explode every time the timer reaches 1000
   2231  0f6b				   explode
   2232  0f6b							; Set xpos of all balls
   2233  0f6b							; ISAR = 0x12
   2234  0f6b		       72		      LIS	$2	; 0f6b 72
   2235  0f6c		       24 10		      AI	$10	; 0f6c 24 10
   2236  0f6e		       0b		      LR	IS,A	; 0f6e 0b
   2237  0f6f							; r0 = 9
   2238  0f6f		       79		      LIS	$9	; 0f6f 79
   2239  0f70		       50		      LR	$0,A	; 0f70 50
   2240  0f71							; (ISAR) = (0x80 & (ISAR)) + 0x30
   2241  0f71		       20 80	   A0f71      LI	$80	; 0f71 20 80
   2242  0f73		       fc		      NS	(IS)	; 0f73 fc
   2243  0f74		       24 30		      AI	$30	; 0f74 24 30
   2244  0f76		       5c		      LR	(IS),A	; 0f76 5c
   2245  0f77							;ISAR++
   2246  0f77		       0a		      LR	A,IS	; 0f77 0a
   2247  0f78		       1f		      INC		; 0f78 1f
   2248  0f79		       0b		      LR	IS,A	; 0f79 0b
   2249  0f7a							; r0--
   2250  0f7a		       30		      DS	$0	; 0f7a 30
   2251  0f7b							; if r0 != 0, loop back
   2252  0f7b		       94 f5		      BNZ	A0f71	; 0f7b 94 f5
   2253  0f7d
   2254  0f7d							; ISAR += 2
   2255  0f7d		       0a		      LR	A,IS	; 0f7d 0a
   2256  0f7e		       24 02		      AI	$02	; 0f7e 24 02
   2257  0f80		       0b		      LR	IS,A	; 0f80 0b
   2258  0f81
   2259  0f81							; Set ypos of all balls
   2260  0f81							; r0 = 9
   2261  0f81		       79		      LIS	$9	; 0f81 79
   2262  0f82		       50		      LR	$0,A	; 0f82 50
   2263  0f83							; (ISAR) = ((ISAR) & 0x80) + 0x22
   2264  0f83		       20 80	   A0f83      LI	$80	; 0f83 20 80
   2265  0f85		       fc		      NS	(IS)	; 0f85 fc
   2266  0f86		       24 22		      AI	$22	; 0f86 24 22
   2267  0f88		       5c		      LR	(IS),A	; 0f88 5c
   2268  0f89							; ISAR++
   2269  0f89		       0a		      LR	A,IS	; 0f89 0a
   2270  0f8a		       1f		      INC		; 0f8a 1f
   2271  0f8b		       0b		      LR	IS,A	; 0f8b 0b
   2272  0f8c							; r0--
   2273  0f8c		       30		      DS	$0	; 0f8c 30
   2274  0f8d							; if r0 != 0, loop back
   2275  0f8d		       94 f5		      BNZ	A0f83	; 0f8d 94 f5
   2276  0f8f
   2277  0f8f							; (ISAR) = reg_a, ISAR++, (ISAR) = reg_a
   2278  0f8f		       4a		      LR	A,$a	; 0f8f 4a
   2279  0f90		       5d		      LR	(IS)+,A	; 0f90 5d
   2280  0f91		       5d		      LR	(IS)+,A	; 0f91 5d
   2281  0f92
   2282  0f92							; Clear top bit of game mode
      0  0f92					      SETISAR	gameMode
      1  0f92		       67		      lisu	[[gameMode] >> 3]
      2  0f93		       6d		      lisl	[[gameMode] & %111]
   2284  0f94							;		  LISU 7		   ; 0f92 67
   2285  0f94							;		 LISL 5 		  ; 0f93 6d
   2286  0f94		       4c		      LR	A,(IS)	; 0f94 4c
   2287  0f95		       13		      SL	1	; 0f95 13
   2288  0f96		       12		      SR	1	; 0f96 12
   2289  0f97		       5c		      LR	(IS),A	; 0f97 5c
   2290  0f98							; Exit
   2291  0f98		       29 0d a0 	      JMP	mainLoop	; 0f98 29 0d a0
   2292  0f9b
   2293  0f9b		       b2		      db.b	$b2	; Unused?
   2294  0f9c							; Free space - 94 bytes!
   2295  0f9c		       ff ff ff ff*	      db.b	$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
   2296  0fad		       ff ff ff ff*	      db.b	$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
   2297  0fbe		       ff ff ff ff*	      db.b	$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
   2298  0fcf		       ff ff ff ff*	      db.b	$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
   2299  0fe0		       ff ff ff ff*	      db.b	$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
   2300  0ff1		       ff ff ff ff*	      db.b	$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
   2301  1000							; EoF
